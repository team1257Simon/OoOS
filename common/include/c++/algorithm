#ifndef __ALGORITHM
#define __ALGORITHM
#include <bits/stl_algobase.hpp>
#include <bits/functional_compare.hpp>
#include <string>
#include <vector>
#include <compare>
namespace std
{
	namespace ext
	{
		template<typename DT, typename CT, typename TT, typename AT> concept __str_delim = char_type<CT> && char_traits_type<TT, CT>  && allocator_object<AT, CT> && (is_same_v<DT, typename std::basic_string<CT, TT, AT>::const_pointer> || is_same_v<DT, typename std::basic_string<CT, TT, AT>::value_type> || std::convertible_to<DT, std::basic_string<CT, TT, AT>>);
		/**
		 * Split a string around a given delimiter, keeping only the elements between the delimiter(s).
		 * @param str a string
		 * @param delim a character or string to use as a delimiter
		 * @return A vector containing the split string(s), or simply the string itself if the delimiter is not found. If the string is empty, returns an empty vector.
		 */
		template<char_type CT, char_traits_type<CT> TT, allocator_object<CT> AT, __str_delim<CT, TT, AT> DT>
		std::vector<std::basic_string<CT, TT, AT>> split(std::basic_string<CT, TT, AT> const& str, DT delim)
		{
			std::vector<std::basic_string<CT, TT, AT>> result{};
			typename std::basic_string<CT, TT, AT>::const_iterator i = str.begin(), j;
			do { j = str.find(delim, i); result.emplace_back(i, j); i = ++j; } while(j < str.end());
			return result;
		}
		template<char_type CT, char_traits_type<CT> TT, allocator_object<CT> AT, __str_delim<CT, TT, AT> DT>
		std::basic_string<CT, TT, AT> join(std::vector<std::basic_string<CT, TT, AT>> const& vec, DT delim = DT())
		{
			typedef decltype(vec.begin()) iterator;
			std::basic_string<CT, TT, AT> result{};
			for(iterator i = vec.begin(); i != vec.end(); i++)
			{
				result += *i;
				iterator test_adv(i);
				if(++test_adv != vec.end() && delim) result += delim;
			}
			return result;
		}
	}
	namespace __detail
	{
		template<typename T> concept __valid_ordering = std::is_same_v<T, std::strong_ordering> || std::is_same_v<T, std::weak_ordering> || std::is_same_v<T, std::partial_ordering>;
		template<typename FT, typename T, typename U> concept __three_way_comparator = requires(FT ft, T t, U u) { { ft(t, u) } -> __valid_ordering; };
	}
	template<typename T, typename U, matching_input_iterator<T> IT, matching_input_iterator<U> JT, __detail::__three_way_comparator<T, U> CT>
	constexpr auto lexicographical_compare_three_way(IT first1, IT last1, JT first2, JT last2, CT comp)
		-> decltype(comp(*first1, *first2))
	{
		using ret_t = decltype(comp(*first1, *first2));
		bool x1, x2;
		for(x1 = (first1 == last1), x2 = (first2 == last2); !x1 && !x2; x1 = (++first1 == last1), x2 = (++first2 == last2)) if(ret_t c = comp(*first1, *first2); c != std::strong_ordering::equal) return c;
		return !x1 ? std::strong_ordering::greater : !x2 ? std::strong_ordering::less : std::strong_ordering::equal;
	}
	template<typename T, typename U, matching_input_iterator<T> IT, matching_input_iterator<U> JT> constexpr auto lexicographical_compare_three_way(IT first1, IT last1, JT first2, JT last2) { return lexicographical_compare_three_way(first1, last1, first2, last2, std::compare_three_way{}); }
	template<forward_iterator IT, typename T = iterator_traits<IT>::value_type, typename CT = std::less<T>>
	IT lower_bound(IT first, IT last, T const& value, CT ct)
	{
		IT i, j = first;
		typename iterator_traits<IT>::difference_type count = distance(first, last), step;
		while(count > 0)
		{
			i			= j;
			step		= count / 2;
			advance(i, step);
			if(ct(*i, value)) { j = ++i; count -= step + 1; }
			else count	= step;
		}
		return j;
	}
	template<forward_iterator IT, typename T = iterator_traits<IT>::value_type>
	IT lower_bound(IT first, IT last, T const& value) { return lower_bound(first, last, value, std::less<void>{}); }
}
#endif