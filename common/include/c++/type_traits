#ifndef __TYPETRAITS
#define __TYPETRAITS
#define extension __extension__
#define ARGCHK(T) static_assert(__is_complete_or_unbounded(__type_identity<T> {}), "template argument must be a complete class or an unbounded array")
#define ARGSCHK static_assert((__is_complete_or_unbounded(__type_identity<Args> {}) && ...), "each argument type must be a complete class or an unbounded array")
// Credit goes to the GNU project for these implementations
// GCC / glibcxx is under the GPL
#ifndef _GCC_STDINT_H
#include "stdint.h"
#endif
#include "stddef.h"
namespace std
{
	template <typename T> class reference_wrapper;
	template <typename T, T V> struct integral_constant
	{
		static constexpr T value = V;
		using value_type = T;
		using type = integral_constant<T, V>;
		constexpr operator value_type() const noexcept { return value; }
		constexpr value_type operator()() const noexcept { return value; }
	};
	template <bool V> using __bool_constant = integral_constant<bool, V>;
	using true_type = __bool_constant<true>;
	using false_type = __bool_constant<false>;
	template <bool V> using bool_constant = __bool_constant<V>;
	template <bool, typename T = void> struct enable_if {};
	template <typename T> struct enable_if<true, T> { using type = T; };
	template <bool CT, typename T = void> using __enable_if_t = typename enable_if<CT, T>::type;
	template <bool> struct __conditional { template <typename T, typename> using type = T; };
	template <> struct __conditional<false> { template <typename, typename U> using type = U; };
	template <bool CT, typename TT, typename FT> using __conditional_t = typename __conditional<CT>::template type<TT, FT>;
	template <typename T> struct __type_identity { using type = T; };
	template <typename T> using __type_identity_t = typename __type_identity<T>::type;
	namespace __detail
	{
		template <typename T, typename...> using __first_t = T;
		template <typename...BN> auto __or_fn(int) -> __first_t<false_type, __enable_if_t<!bool(BN::value)> ...>;
		template <typename...BN> auto __or_fn(...) -> true_type;
		template <typename...BN> auto __and_fn(int) -> __first_t<true_type, __enable_if_t<bool(BN::value)> ...>;
		template <typename...BN> auto __and_fn(...) -> false_type;
		template <typename, typename B1, typename...BN> struct __disjunction_impl { using type = B1; };
		template <typename B1, typename B2, typename...BN> struct __disjunction_impl<__enable_if_t <!bool(B1::value)>, B1, B2, BN...> { using type = typename __disjunction_impl<void, B2, BN...>::type; };
		template <typename, typename B1, typename...BN> struct __conjunction_impl { using type = B1; };
		template <typename B1, typename B2, typename...BN> struct __conjunction_impl<__enable_if_t <bool(B1::value)>, B1, B2, BN...> { using type = typename __conjunction_impl<void, B2, BN...>::type; };
	}
	template <typename...BN> struct __or_ : decltype(__detail::__or_fn <BN...> (0)) {};
	template <typename...BN> struct __and_ : decltype(__detail::__and_fn <BN...> (0)) {};
	template <typename P> struct __not_ : __bool_constant<!bool(P::value)> {};
	template <typename...BN> inline constexpr bool __or_v = __or_<BN...>::value;
	template <typename...BN> inline constexpr bool __and_v = __and_<BN...>::value;
	template <typename...BN> struct conjunction : __detail::__conjunction_impl <void, BN...>::type {};
	template <> struct conjunction<> : true_type {};
	template <typename...BN> struct disjunction : __detail::__disjunction_impl <void, BN...>::type {};
	template <> struct disjunction<> : false_type {};
	template <typename P> struct negation : __not_<P>::type {};
	template <typename...BN> inline constexpr bool conjunction_v = conjunction<BN...>::value;
	template <typename...BN> inline constexpr bool disjunction_v = disjunction<BN...>::value;
	template <typename P> inline constexpr bool negation_v = negation<P>::value;
	template <typename> struct is_reference;
	template <typename> struct is_function;
	template <typename> struct is_void;
	template <typename> struct remove_cv;
	template <typename> struct is_const;
	template <typename> struct __is_array_unknown_bounds;
	template <typename T, size_t = sizeof(T)> constexpr true_type __is_complete_or_unbounded(__type_identity <T>) { return {}; }
	template <typename IDT, typename NT = typename IDT::type> constexpr typename __or_<is_reference<NT>, is_function<NT>, is_void<NT>, __is_array_unknown_bounds<NT>>::type __is_complete_or_unbounded(IDT) { return {}; }
	template <typename T> using __remove_cv_t = typename remove_cv<T>::type;
	template <typename T> struct is_void: public false_type {};
	template <> struct is_void<void> : public true_type {};
	template <> struct is_void<const void> : public true_type {};
	template <> struct is_void<volatile void> : public true_type {};
	template <> struct is_void<const volatile void> : public true_type {};
	template <typename> struct __is_integral_helper : public false_type {};
	template <> struct __is_integral_helper<bool> : public true_type {};
	template <> struct __is_integral_helper<char> : public true_type {};
	template <>	struct __is_integral_helper<signed char> : public true_type {};
	template <>	struct __is_integral_helper<unsigned char> : public true_type {};
	template <> struct __is_integral_helper<char8_t> : public true_type{};
	template <>	struct __is_integral_helper<wchar_t> : public true_type {};
	template <>	struct __is_integral_helper<char16_t> : public true_type {};
	template <>	struct __is_integral_helper<char32_t> : public true_type {};
	template <>	struct __is_integral_helper<short> : public true_type {};
	template <>	struct __is_integral_helper<unsigned short> : public true_type {};
	template <>	struct __is_integral_helper<int> : public true_type {};
	template <>	struct __is_integral_helper<unsigned int> : public true_type {};
	template <>	struct __is_integral_helper<long> : public true_type {};
	template <>	struct __is_integral_helper<unsigned long> : public true_type {};
	template <>	struct __is_integral_helper<long long> : public true_type {};
	template <>	struct __is_integral_helper<unsigned long long> : public true_type {};
	template <typename T> struct is_integral : public __is_integral_helper<__remove_cv_t<T>>::type {};
	template <typename>	struct __is_floating_point_helper : public false_type {};
	template <> struct __is_floating_point_helper<float> : public true_type {};
	template <> struct __is_floating_point_helper<double> : public true_type {};
	template <> struct __is_floating_point_helper<long double> : public true_type {};
	template <typename T> struct is_floating_point : public __is_floating_point_helper<__remove_cv_t<T>>::type {};
	template <typename> struct is_array : public false_type {};
	template <typename T, size_t S> struct is_array<T[S]> : public true_type {};
	template <typename T> struct is_array<T[]> : public true_type {};
	template <typename> struct __is_pointer_helper : public false_type {};
	template <typename T> struct __is_pointer_helper<T*> : public true_type {};
	template <typename T> struct is_pointer : public __is_pointer_helper<__remove_cv_t<T>>::type {};
	template <typename> struct is_lvalue_reference : public false_type {};
	template <typename T> struct is_lvalue_reference<T&> : public true_type {};
	template <typename> struct is_rvalue_reference : public false_type {};
	template <typename T> struct is_rvalue_reference<T&&> : public true_type {};
	template <typename>	struct __is_member_object_pointer_helper : public false_type {};
	template <typename T, typename CT> struct __is_member_object_pointer_helper<T CT::*> : public __not_<is_function<T>>::type {};
	template <typename T> struct is_member_object_pointer : public __is_member_object_pointer_helper<__remove_cv_t<T>>::type {};
	template <typename> struct __is_member_function_pointer_helper : public false_type {};
	template <typename T, typename CT> struct __is_member_function_pointer_helper<T CT::*> : public is_function<T>::type {};
	template <typename T> struct is_member_function_pointer : public __is_member_function_pointer_helper<__remove_cv_t<T>>::type {};
	template <typename T> struct is_enum : public __bool_constant<__is_enum(T)> {};
	template <typename T> struct is_union : public __bool_constant<__is_union(T)> {};
	template <typename T> struct is_class : public __bool_constant<__is_class(T)> {};
	template <typename T> struct is_function : public __bool_constant<!is_const<const T>::value> {};
	template <typename T> struct is_function<T&> : public false_type {};
	template <typename T> struct is_function<T&&> : public false_type {};
	template <typename T> struct is_reference : public false_type {};
	template <typename T> struct is_reference<T&> : public true_type {};
	template <typename T> struct is_reference<T&&> : public true_type {};
    template <typename T> struct is_null_pointer : public false_type {};
    template <> struct is_null_pointer<nullptr_t> : public true_type {};
    template <> struct is_null_pointer<const nullptr_t> : public true_type {};
    template <> struct is_null_pointer<volatile nullptr_t> : public true_type {};
    template <> struct is_null_pointer<const volatile nullptr_t> : public true_type {};
	template <typename T> struct is_arithmetic : public __or_<is_integral<T>, is_floating_point<T>>::type {};
	template <typename T> struct is_fundamental : public __or_<is_arithmetic<T>, is_void<T>, is_null_pointer<T>>::type {};
	template <typename> struct is_member_pointer;
	template <typename T> struct is_scalar: public __or_<is_arithmetic<T>, is_enum<T>, is_pointer<T>, is_member_pointer<T>, is_null_pointer<T>>::type {};
	template <typename T> struct is_compound : public __bool_constant<!is_fundamental <T>::value> {};
	template <typename T> struct __is_member_pointer_helper : public false_type {};
	template <typename T, typename CT> struct __is_member_pointer_helper<T CT::*> : public true_type {};
	template <typename T> struct is_member_pointer : public __is_member_pointer_helper<__remove_cv_t<T>>::type {};
	template <typename, typename> struct is_same;
	template <typename T, typename...Ts> using __is_one_of = __or_<is_same<T, Ts> ...>;
	__extension__ template <typename T> using __is_signed_integer = __is_one_of<__remove_cv_t<T>, signed char, signed short, signed int, signed long, signed long long>;
	__extension__ template <typename T> using __is_unsigned_integer = __is_one_of<__remove_cv_t<T>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
	template <typename T> using __is_standard_integer = __or_<__is_signed_integer<T>, __is_unsigned_integer<T>>;
	template <typename T> struct is_object : public __or_<is_scalar<T>, is_array<T>, is_union<T>, is_class<T>>::type {};
	template <typename...> using __void_t = void;
	template <typename> struct is_const : public false_type {};
	template <typename T> struct is_const<T const> : public true_type {};
	template <typename> struct is_volatile : public false_type {};
	template <typename T> struct is_volatile<T volatile> : public true_type {};
	template <typename T> struct is_trivial : public __bool_constant<__is_trivial(T)> { ARGCHK(T); };
	template <typename T> struct is_trivially_copyable : public __bool_constant<__is_trivially_copyable(T)> { ARGCHK(T); };
	template <typename T> struct is_standard_layout : public __bool_constant<__is_standard_layout(T)> { ARGCHK(T); };
	template <typename T> struct is_empty : public __bool_constant<__is_empty(T)> {};
	template <typename T> struct is_polymorphic : public __bool_constant<__is_polymorphic(T)> {};
	template <typename T> struct is_final : public __bool_constant<__is_final(T)> {};
	template <typename T> struct is_abstract : public __bool_constant<__is_abstract(T)> {};
	template <typename T, bool = is_arithmetic<T>::value> struct __is_signed_helper : public false_type {};
	template <typename T> struct __is_signed_helper<T, true> : public __bool_constant<T(-1) < T(0)> {};
	template <typename T> struct is_signed : public __is_signed_helper<T>::type {};
	template <typename T> struct is_unsigned : public __and_<is_arithmetic<T>, __not_<is_signed<T>>>::type {};
	template <typename T, typename U = T&&> U __declval(int);
	template <typename T> T __declval(long);
	template <typename T> auto declval() noexcept -> decltype(__declval<T>(0));
	template <typename> struct remove_all_extents;
	template <typename T> struct __is_array_known_bounds : public false_type {};
	template <typename T, size_t S> struct __is_array_known_bounds<T[S]> : public true_type {};
	template <typename T> struct __is_array_unknown_bounds : public false_type {};
	template <typename T> struct __is_array_unknown_bounds<T[]> : public true_type {};
	struct __do_is_destructible_impl { template <typename T, typename = decltype(declval<T&>().~T())>  static true_type __test(int); template <typename> static false_type __test(...); };
	template <typename T> struct __is_destructible_impl : public __do_is_destructible_impl { using type = decltype(__test<T>(0)); };
	template <typename T, bool = __or_<is_void<T>, __is_array_unknown_bounds<T>, is_function<T>>::value, bool = __or_<is_reference<T>, is_scalar<T>>::value> struct __is_destructible_safe;
	template <typename T> struct __is_destructible_safe<T, false, false> : public __is_destructible_impl<typename remove_all_extents<T>::type>::type {};
	template <typename T> struct __is_destructible_safe<T, true, false> : public false_type {};
	template <typename T> struct __is_destructible_safe<T, false, true> : public true_type {};
	template <typename T> struct is_destructible: public __is_destructible_safe<T>::type { ARGCHK(T); }; 
	struct __do_is_nt_destructible_impl { template <typename T> static __bool_constant<noexcept(declval<T&> ().~T())> __test(int); template <typename> static false_type __test(...); };
	template <typename T> struct __is_nt_destructible_impl : public __do_is_nt_destructible_impl { using type = decltype(__test<T>(0)); };
	template <typename T, bool = __or_<is_void <T>, __is_array_unknown_bounds<T>, is_function<T>>::value, bool = __or_<is_reference<T>, is_scalar<T>>::value> struct __is_nt_destructible_safe;
	template <typename T> struct __is_nt_destructible_safe<T, false, false> : public __is_nt_destructible_impl<typename remove_all_extents<T>::type>::type {};
	template <typename T> struct __is_nt_destructible_safe<T, true, false> : public false_type {};
	template <typename T> struct __is_nt_destructible_safe<T, false, true> : public true_type {};
	template <typename T> struct is_nothrow_destructible : public __is_nt_destructible_safe<T>::type { ARGCHK(T); };
	template <typename T, typename...Args> using __is_constructible_impl = __bool_constant<__is_constructible(T, Args...)>;
	template <typename T, typename...Args> struct is_constructible : public __is_constructible_impl<T, Args...> { ARGCHK(T); };
	template <typename T> struct is_default_constructible: public __is_constructible_impl<T> { ARGCHK(T); };
	template <typename T, typename = void> struct __add_lvalue_reference_helper { using type = T; };
	template <typename T> struct __add_lvalue_reference_helper<T, __void_t<T&>> { using type = T&; };
	template <typename T> using __add_lval_ref_t = typename __add_lvalue_reference_helper<T>::type;
	template <typename T> struct is_copy_constructible : public __is_constructible_impl<T, __add_lval_ref_t<const T>> { ARGCHK(T); };
	template <typename T, typename = void> struct __add_rvalue_reference_helper { using type = T; };
	template <typename T> struct __add_rvalue_reference_helper<T, __void_t<T&&>> { using type = T&&; };
	template <typename T> using __add_rval_ref_t = typename __add_rvalue_reference_helper<T>::type;
	template <typename T> struct is_move_constructible : public __is_constructible_impl<T, __add_rval_ref_t<T>> { ARGCHK(T); };
	template <typename T, typename...Args> using __is_nothrow_constructible_impl = __bool_constant<__is_nothrow_constructible(T, Args...)>;
	template <typename T, typename...Args> struct is_nothrow_constructible : public __is_nothrow_constructible_impl<T, Args...> { ARGCHK(T); };
	template <typename T> struct is_nothrow_default_constructible: public __is_nothrow_constructible_impl<T> { ARGCHK(T); };
	template <typename T> struct is_nothrow_copy_constructible : public __is_nothrow_constructible_impl<T, __add_lval_ref_t<const T>> { ARGCHK(T); };
	template <typename T> struct is_nothrow_move_constructible : public __is_nothrow_constructible_impl<T, __add_rval_ref_t<T>> { ARGCHK(T); };
	template <typename T, typename U> using __is_assignable_impl = __bool_constant<__is_assignable(T, U)>;
	template <typename T, typename U> struct is_assignable: public __is_assignable_impl<T, U> { ARGCHK(T); };
	template <typename T> struct is_copy_assignable : public __is_assignable_impl<__add_lval_ref_t<T>, __add_lval_ref_t<const T>> { ARGCHK(T); };
	template <typename T> struct is_move_assignable : public __is_assignable_impl<__add_lval_ref_t<T>, __add_rval_ref_t<T>> { ARGCHK(T); };
	template <typename T, typename U> using __is_nothrow_assignable_impl = __bool_constant<__is_nothrow_assignable(T, U)>;
	template <typename T, typename U> struct is_nothrow_assignable: public __is_nothrow_assignable_impl<T, U> { ARGCHK(T); };
	template <typename T> struct is_nothrow_copy_assignable : public __is_nothrow_assignable_impl<__add_lval_ref_t<T>, __add_lval_ref_t<const T>> { ARGCHK(T); };
	template <typename T> struct is_nothrow_move_assignable : public __is_nothrow_assignable_impl<__add_lval_ref_t<T>, __add_rval_ref_t<T>> { ARGCHK(T); };
	template <typename T, typename...Args> using __is_trivially_constructible_impl = __bool_constant<__is_trivially_constructible(T, Args...)>;
	template <typename T, typename...Args> struct is_trivially_constructible : public __is_trivially_constructible_impl<T, Args...> { ARGCHK(T); };
	template <typename T> struct is_trivially_default_constructible: public __is_trivially_constructible_impl<T> { ARGCHK(T); };
	struct __do_is_implicitly_default_constructible_impl { template <typename T> static void __helper(const T & ); template <typename T> static true_type __test(const T &, decltype(__helper <const T &> ({})) * = 0); static false_type __test(...); };
	template <typename T> struct __is_implicitly_default_constructible_impl : public __do_is_implicitly_default_constructible_impl { using type = decltype(__test(declval<T>())); };
	template <typename T> struct __is_implicitly_default_constructible_safe : public __is_implicitly_default_constructible_impl<T>::type {};
	template <typename T> struct __is_implicitly_default_constructible : public __and_<__is_constructible_impl<T>, __is_implicitly_default_constructible_safe<T>>::type {};
	template <typename T> struct is_trivially_copy_constructible : public __is_trivially_constructible_impl<T, __add_lval_ref_t<const T>> { ARGCHK(T); };
	template <typename T> struct is_trivially_move_constructible : public __is_trivially_constructible_impl<T, __add_rval_ref_t<T>> { ARGCHK(T); };
	template <typename T, typename U> using __is_trivially_assignable_impl = __bool_constant<__is_trivially_assignable(T, U)>;
	template <typename T, typename U> struct is_trivially_assignable: public __is_trivially_assignable_impl<T, U> { ARGCHK(T); };
	template <typename T> struct is_trivially_copy_assignable : public __is_trivially_assignable_impl<__add_lval_ref_t<T>, __add_lval_ref_t<const T>> { ARGCHK(T); };
	template <typename T> struct is_trivially_move_assignable : public __is_trivially_assignable_impl<__add_lval_ref_t<T>, __add_rval_ref_t<T>> { ARGCHK(T); };
	template <typename T> struct is_trivially_destructible : public __and_<__is_destructible_safe<T>, __bool_constant<__has_trivial_destructor(T)>>::type { ARGCHK(T); };
	template <typename T> struct has_virtual_destructor : public __bool_constant<__has_virtual_destructor(T)> { ARGCHK(T); };
	template <typename T> struct alignment_of: public integral_constant<size_t, alignof(T)> { ARGCHK(T); };
	template <typename> struct rank: public integral_constant<size_t, 0> {};
	template <typename T, size_t S> struct rank<T[S]> : public integral_constant<size_t, 1 + rank<T>::value> {};
	template <typename T> struct rank<T[]> : public integral_constant<size_t, 1 + rank<T>::value> {};
	template <typename, unsigned UI1 = 0> struct extent : public integral_constant<size_t, 0> {};
	template <typename T, size_t S> struct extent<T[S], 0> : public integral_constant<size_t, S> {};
	template <typename T, unsigned UI1, size_t S> struct extent<T[S], UI1> : public extent<T, UI1 - 1>::type {};
	template <typename T> struct extent<T[], 0> : public integral_constant<size_t, 0> {};
	template <typename T, unsigned UI1> struct extent<T[], UI1> : public extent<T, UI1 - 1>::type {};
	template <typename T, typename U> struct is_same : public false_type {};
	template <typename T> struct is_same<T, T> : public true_type {};
	template <typename BT, typename DT> struct is_base_of : public __bool_constant<__is_base_of(BT, DT)> {};
	template <typename FT, typename TT, bool = __or_<is_void <FT>, is_function<TT>, is_array<TT>>::value> struct __is_convertible_helper { using type = typename is_void<TT>::type; };
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
	template <typename FT, typename TT> class __is_convertible_helper<FT, TT, false> { template <typename T1> static void __test_aux(T1) noexcept; template <typename F1, typename T1, typename = decltype(__test_aux <T1> (declval<F1>()))> static true_type __test(int); template <typename, typename> static false_type __test(...); public: using type = decltype(__test <FT, TT> (0)); };
	#pragma GCC diagnostic pop
	template <typename FT, typename TT> struct is_convertible : public __is_convertible_helper<FT, TT>::type {};
	template <typename TET, typename FET> using __is_array_convertible = is_convertible<FET(*)[], TET(*)[]>;
	template <typename T> struct remove_const { using type = T; };
	template <typename T> struct remove_const<T const> { using type = T; };
	template <typename T> struct remove_volatile { using type = T; };
	template <typename T> struct remove_volatile<T volatile> { using type = T; };
	template <typename T> struct remove_cv { using type = T; };
	template <typename T> struct remove_cv<const T> { using type = T; };
	template <typename T> struct remove_cv<volatile T> { using type = T; };
	template <typename T> struct remove_cv<const volatile T> { using type = T; };
	template <typename T> struct add_const { using type = T const; };
	template <typename T> struct add_volatile { using type = T volatile; };
	template <typename T> struct add_cv { using type = T const volatile; };
	template <typename T> using remove_const_t = typename remove_const<T>::type;
	template <typename T> using remove_volatile_t = typename remove_volatile<T>::type;
	template <typename T> using remove_cv_t = typename remove_cv<T>::type;
	template <typename T> using add_const_t = typename add_const<T>::type;
	template <typename T> using add_volatile_t = typename add_volatile<T>::type;
	template <typename T> using add_cv_t = typename add_cv<T>::type;
	template <typename T> struct remove_reference { using type = T; };
	template <typename T> struct remove_reference<T&> { using type = T; };
	template <typename T> struct remove_reference<T&&> { using type = T; };
	template <typename T> struct add_lvalue_reference { using type = __add_lval_ref_t<T>; };
	template <typename T> struct add_rvalue_reference { using type = __add_rval_ref_t<T>; };
	template <typename T> using remove_reference_t = typename remove_reference<T>::type;
	template <typename T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
	template <typename T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;
	template <typename UQ, bool IC, bool IV> struct __cv_selector;
	template <typename UQ> struct __cv_selector<UQ, false, false> { using __type = UQ; };
	template <typename UQ> struct __cv_selector<UQ, false, true> { using __type = volatile UQ; };
	template <typename UQ> struct __cv_selector<UQ, true, false> { using __type = const UQ; };
	template <typename UQ> struct __cv_selector<UQ, true, true> { using __type = const volatile UQ; };
	template <typename QT, typename UQ, bool IC = is_const<QT>::value, bool IV = is_volatile<QT>::value> class __match_cv_qualifiers { using __match = __cv_selector<UQ, IC, IV>; public: using __type = typename __match::__type; };
	template <typename T> struct __make_unsigned { using __type = T; };
	template <> struct __make_unsigned<char> { using __type = unsigned char; };
	template <> struct __make_unsigned<short> { using __type = unsigned short; };
	template <> struct __make_unsigned<int> { using __type = unsigned int; };
	template <> struct __make_unsigned<long> { using __type = unsigned long; };
	template <> struct __make_unsigned<long long> { using __type = unsigned long long; };
	template <typename T, bool II = is_integral<T>::value, bool IE = __is_enum(T)> class __make_unsigned_selector;
	template <typename T> class __make_unsigned_selector<T, true, false> { using __unsigned_type = typename __make_unsigned<__remove_cv_t<T>>::__type; public: using __type = typename __match_cv_qualifiers<T, __unsigned_type>::__type; };
	class __make_unsigned_selector_base
	{
	protected: 
		template <typename...> struct __list {};
		template <typename T, typename...U> struct __list<T, U...> : __list<U...> { static constexpr size_t __size = sizeof(T); };
		template <size_t S, typename T, bool = (S <= T::__size)> struct __select;
		template <size_t S, typename UI1, typename...UIs> struct __select<S, __list<UI1, UIs...>, true> { using __type = UI1; };
		template <size_t S, typename UI1, typename...UIs> struct __select<S, __list<UI1, UIs...>, false> : __select<S, __list<UIs...>> {};
	};
	template <typename T> class __make_unsigned_selector<T, false, true> : __make_unsigned_selector_base { using UIs = __list<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>; using __unsigned_type = typename __select<sizeof(T), UIs>::__type; public: using __type = typename __match_cv_qualifiers<T, __unsigned_type>::__type; };
	template <> struct __make_unsigned<wchar_t> { using __type = typename __make_unsigned_selector<wchar_t, false, true>::__type; };
	template <typename T> struct make_unsigned { using type = typename __make_unsigned_selector<T>::__type; };
	template <> struct make_unsigned<bool>;
	template <> struct make_unsigned<bool const>;
	template <> struct make_unsigned<bool volatile>;
	template <> struct make_unsigned<bool const volatile>;
	template <typename T> struct __make_signed { using __type = T; };
	template <> struct __make_signed<char> { using __type = signed char; };
	template <> struct __make_signed<unsigned char> { using __type = signed char; };
	template <> struct __make_signed<unsigned short> { using __type = signed short; };
	template <> struct __make_signed<unsigned int> { using __type = signed int; };
	template <> struct __make_signed<unsigned long> { using __type = signed long; };
	template <> struct __make_signed<unsigned long long> { using __type = signed long long; };
	template <typename T, bool II = is_integral<T>::value, bool IE = __is_enum(T)> class __make_signed_selector;
	template <typename T> class __make_signed_selector<T, true, false> { using __signed_type = typename __make_signed<__remove_cv_t<T>>::__type; public: using __type = typename __match_cv_qualifiers<T, __signed_type>::__type; };
	template <typename T> class __make_signed_selector<T, false, true> { using __unsigned_type = typename __make_unsigned_selector<T>::__type; public: using __type = typename __make_signed_selector<__unsigned_type>::__type; };
	template <> struct __make_signed<wchar_t> { using __type = typename __make_signed_selector<wchar_t, false, true>::__type; };
	template <typename T> struct make_signed { using type = typename __make_signed_selector<T>::__type; };
	template <> struct make_signed<bool>;
	template <> struct make_signed<bool const>;
	template <> struct make_signed<bool volatile>;
	template <> struct make_signed<bool const volatile>;
	template <typename T> using make_signed_t = typename make_signed<T>::type;
	template <typename T> struct remove_extent { using type = T; };
	template <typename T, size_t S> struct remove_extent<T[S]> { using type = T; };
	template <typename T> struct remove_extent<T[]> { using type = T; };
	template <typename T> struct remove_all_extents { using type = T; };
	template <typename T, size_t S> struct remove_all_extents<T[S]> { using type = typename remove_all_extents<T>::type; };
	template <typename T> struct remove_all_extents<T[]> { using type = typename remove_all_extents<T>::type; };
	template <typename T> using remove_extent_t = typename remove_extent<T>::type;
	template <typename T> using remove_all_extents_t = typename remove_all_extents<T>::type;
	template <typename T, typename> struct __remove_pointer_helper { using type = T; };
	template <typename T, typename U> struct __remove_pointer_helper<T, U*> { using type = U; };
	template <typename T> struct remove_pointer: public __remove_pointer_helper<T, __remove_cv_t<T>> {};
	template <typename T, typename = void> struct __add_pointer_helper { using type = T; };
	template <typename T> struct __add_pointer_helper<T, __void_t<T*>> { using type = T*; };
	template <typename T> struct add_pointer: public __add_pointer_helper<T> {};
	template <typename T> struct add_pointer<T&> { using type = T*; };
	template <typename T> struct add_pointer<T&&> { using type = T*; };
	template <typename T> using remove_pointer_t = typename remove_pointer<T>::type;
	template <typename T> using add_pointer_t = typename add_pointer<T>::type;
	template <size_t N> struct __aligned_storage_msa { union __type { unsigned char __data[N]; struct __attribute__((__aligned__)) {} __alignment; }; };
	template<size_t N, size_t A = alignof(typename __aligned_storage_msa<N>::__type)> struct aligned_storage { union type { unsigned char __data[N]; struct __attribute__((__aligned__((A)))) {} __alignment; }; };
	template <typename...Ts> struct __strictest_alignment { static const size_t __alignment = 0; static const size_t __size = 0; };
	template <typename T, typename...Ts> struct __strictest_alignment<T, Ts...> { static const size_t __alignment = alignof(T)> __strictest_alignment<Ts...>::__alignment ? alignof(T) : __strictest_alignment<Ts...>::__alignment; static const size_t __size = sizeof(T)> __strictest_alignment<Ts...>::__size ? sizeof(T) : __strictest_alignment<Ts...>::__size; };
	template <typename U> struct __decay_selector : __conditional_t<is_const<const U>::value, remove_cv<U>, add_pointer<U>> {};
	template <typename U, size_t N> struct __decay_selector<U[N]> { using type = U*; };
	template <typename U> struct __decay_selector<U[]> { using type = U*; };
	template <typename T> struct decay { using type = typename __decay_selector<T>::type; };
	template <typename T> struct decay<T&> { using type = typename __decay_selector<T>::type; };
	template <typename T> struct decay<T&&> { using type = typename __decay_selector<T>::type; };
	template <typename T> struct __strip_reference_wrapper { using __type = T; };
	template <typename T> struct __strip_reference_wrapper<reference_wrapper <T>> { using __type = T &; };
	template <typename T> using __decay_t = typename decay<T>::type;
	template <typename T> using __decay_and_strip = __strip_reference_wrapper<__decay_t <T>>;
	template <typename...CT> using __require_all = __enable_if_t<__and_<CT...>::value>;
	template <typename T> using __remove_cvref_t = typename remove_cv<typename remove_reference<T>::type>::type;
	template <bool CT, typename TCT, typename FCT> struct conditional { using type = TCT; };
	template <typename TCT, typename FCT> struct conditional<false, TCT, FCT> { using type = FCT; };
	template <typename...T> struct common_type;
	template <typename T> struct __success_type { using type = T; };
	struct __failure_type {};
	struct __do_common_type_impl
	{
		template <typename T, typename U> using __cond_t = decltype(true ? declval<T>() : declval<U>());
		template <typename T, typename U> static __success_type<__decay_t<__cond_t<T, U>>> __test(int);
		template <typename T, typename U> static __success_type<__remove_cvref_t<__cond_t<T const&, U const&>>> __type_test_2(int);
		template <typename, typename> static __failure_type __type_test_2(...);
		template <typename T, typename U> static decltype(__type_test_2<T, U>(0)) __test(...);
	};
	template <> struct common_type<> {};
	template <typename T0> struct common_type<T0> : public common_type<T0, T0> {};
	template <typename T1, typename T2, typename D1 = __decay_t<T1>, typename D2 = __decay_t<T2>> struct __common_type_impl { using type = common_type<D1, D2>; };
	template <typename T1, typename T2> struct __common_type_impl<T1, T2, T1, T2> : private __do_common_type_impl { using type = decltype(__test<T1, T2>(0)); };
	template <typename T1, typename T2> struct common_type<T1, T2> : public __common_type_impl<T1, T2>::type {};
	template <typename...> struct __common_type_pack {};
	template <typename, typename, typename = void> struct __common_type_fold;
	template <typename T1, typename T2, typename...PT> struct common_type<T1, T2, PT...>:  public __common_type_fold<common_type<T1, T2>, __common_type_pack<PT...>> {};
	template <typename CT, typename...PT> struct __common_type_fold<CT, __common_type_pack<PT...>, __void_t<typename CT::type>> : public common_type<typename CT::type, PT...> {};
	template <typename CT, typename PT> struct __common_type_fold<CT, PT, void> {};
	template <typename T, bool = __is_enum(T)> struct __underlying_type_impl { using type = __underlying_type(T); };
	template <typename T> struct __underlying_type_impl<T, false> {};
	template <typename T> struct underlying_type : public __underlying_type_impl<T> {};
	template <typename T> struct __declval_protector { static const bool __stop = false; };
	template <typename T> auto declval() noexcept -> decltype(__declval<T>(0)) { static_assert(__declval_protector<T>::__stop, "declval() must not be used in an evaluated context"); return __declval<T>(0); }
	template <typename S> struct result_of;
	struct __invoke_memfun_ref {};
	struct __invoke_memfun_deref {};
	struct __invoke_memobj_ref {};
	struct __invoke_memobj_deref {};
	struct __invoke_other {};
	template <typename T, typename ST> struct __result_of_success : __success_type<T> { using __invoke_type = ST; };
	struct __result_of_memfun_ref_impl { template <typename FT, typename T1, typename...Args> static __result_of_success<decltype((declval<T1>().*declval<FT>())(declval<Args>()...)), __invoke_memfun_ref> __test(int); template <typename...> static __failure_type __test(...); };
	template <typename MPT, typename AT1, typename...Args> struct __result_of_memfun_ref : private __result_of_memfun_ref_impl { using type = decltype(__test <MPT, AT1, Args...> (0)); };
	struct __result_of_memfun_deref_impl { template <typename FT, typename T1, typename...Args> static __result_of_success<decltype(((*declval<T1>()).*declval<FT>())(declval<Args>()...)), __invoke_memfun_deref> __test(int); template <typename...> static __failure_type __test(...); };
	template <typename MPT, typename AT1, typename...Args> struct __result_of_memfun_deref : private __result_of_memfun_deref_impl { using type = decltype(__test <MPT, AT1, Args...> (0)); };
	struct __result_of_memobj_ref_impl { template <typename FT, typename T1> static __result_of_success<decltype(declval<T1>().*declval<FT>()), __invoke_memobj_ref> __test(int); template <typename, typename> static __failure_type __test(...); };
	template <typename MPT, typename AT1> struct __result_of_memobj_ref : private __result_of_memobj_ref_impl { using type = decltype(__test<MPT, AT1>(0)); };
	struct __result_of_memobj_deref_impl { template <typename FT, typename T1> static __result_of_success<decltype((*declval<T1>()).*declval<FT>()), __invoke_memobj_deref> __test(int); template <typename, typename> static __failure_type __test(...); };
	template <typename MPT, typename AT1> struct __result_of_memobj_deref : private __result_of_memobj_deref_impl { using type = decltype(__test <MPT, AT1> (0)); };
	template <typename MPT, typename AT1> struct __result_of_memobj;
	template <typename R, typename CLT, typename AT1> struct __result_of_memobj<R CLT::*, AT1> { using __argval = __remove_cvref_t<AT1>; using __mem_ptr = R CLT::*; using type = typename __conditional_t<__or_ <is_same <__argval, CLT>, is_base_of<CLT, __argval>>::value, __result_of_memobj_ref<__mem_ptr, AT1>, __result_of_memobj_deref<__mem_ptr,	AT1>>::type; };
	template <typename MPT, typename AT1, typename...Args> struct __result_of_memfun;
	template <typename R, typename CLT, typename AT1, typename...Args> struct __result_of_memfun<R CLT::*, AT1, Args...> { using __argval = typename remove_reference<AT1>::type; using __mem_ptr = R CLT::*; using type = typename __conditional_t<is_base_of <CLT, __argval>::value, __result_of_memfun_ref<__mem_ptr, AT1, Args...>, __result_of_memfun_deref<__mem_ptr, AT1, Args...>>::type; };
	template <typename T, typename U = __remove_cvref_t<T>> struct __inv_unwrap { using type = T; };
	template <typename T, typename U> struct __inv_unwrap<T, reference_wrapper<U>> { using type = U &; };
	template <bool, bool, typename FT, typename...Args> struct __result_of_impl { using type = __failure_type; };
	template <typename MPT, typename AT1> struct __result_of_impl<true, false, MPT, AT1> : public __result_of_memobj<__decay_t<MPT>, typename __inv_unwrap<AT1>::type> {};
	template <typename MPT, typename AT1, typename...Args> struct __result_of_impl<false, true, MPT, AT1, Args...> : public __result_of_memfun<__decay_t <MPT>, typename __inv_unwrap<AT1>::type, Args...> {};
	struct __result_of_other_impl { template <typename F2, typename...Args> static __result_of_success<decltype(declval<F2>()(declval<Args>()...)), __invoke_other> __test(int); template <typename...> static __failure_type __test(...); };
	template <typename FT, typename...Args> struct __result_of_impl<false, false, FT, Args...> : private __result_of_other_impl { using type = decltype(__test <FT, Args...> (0)); };
	template <typename FT, typename...Args> struct __invoke_result: public __result_of_impl<is_member_object_pointer <typename remove_reference<FT>::type>::value, is_member_function_pointer<typename remove_reference<FT>::type>::value, FT, Args...>::type {};
	template <typename F2, typename...Args> using __invoke_result_t = typename __invoke_result<F2, Args...>::type;
	template <typename T> using decay_t = typename decay<T>::type;
	template <bool CT, typename T = void> using enable_if_t = typename enable_if<CT, T>::type;
	template <bool CT, typename TCT, typename FCT> using conditional_t = typename conditional<CT, TCT, FCT>::type;
	template <typename...T> using common_type_t = typename common_type<T...>::type;
	template <typename T> using underlying_type_t = typename underlying_type<T>::type;
 	template<typename FT, typename... Args> struct result_of<FT(Args...)> : public __invoke_result<FT, Args...> {};
	template <typename T> using result_of_t = typename result_of<T>::type;
	template <typename...> using void_t = void;
	template <typename DT, typename AlwaysVoid, template <typename...> class OT, typename...Args> struct __detector { using type = DT; using __is_detected = false_type; };
	template <typename DT, template <typename...> class OT, typename...Args> struct __detector<DT, __void_t<OT<Args...>>, OT, Args...> { using type = OT<Args...>; using __is_detected = true_type; };
	template <typename DT, template <typename...> class OT, typename...Args> using __detected_or = __detector<DT, void, OT, Args...>;
	template <typename DT, template <typename...> class OT, typename...Args> using __detected_or_t = typename __detected_or<DT, OT, Args...>::type;
	template <typename T> struct __is_swappable;
	template <typename T> struct __is_nothrow_swappable;
	template <typename> struct __is_tuple_like_impl : false_type {};
	template <typename T> struct __is_tuple_like : public __is_tuple_like_impl<__remove_cvref_t<T>>::type {};
	template <typename T> constexpr inline __require_all<__not_<__is_tuple_like<T>>, is_move_constructible<T>, is_move_assignable<T>> swap(T&, T& ) noexcept(__and_<is_nothrow_move_constructible<T>, is_nothrow_move_assignable<T>>::value);
	template <typename T, size_t N> constexpr inline __enable_if_t<__is_swappable<T>::value> swap(T(&__a)[N], T(&__b)[N]) noexcept(__is_nothrow_swappable<T>::value);
	namespace __swappable_details
	{
		using std::swap;
		struct __do_is_swappable_impl { template<typename T, typename = decltype(swap(declval<T&>(), declval<T&>()))> static true_type __test(int); template<typename> static false_type __test(...); };
		struct __do_is_nothrow_swappable_impl { template<typename T> static __bool_constant<noexcept(swap(declval<T&>(), declval<T&>()))> __test(int); template<typename> static false_type __test(...); };
	}
	template <typename T> struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl { using type = decltype(__test<T>(0)); };
	template <typename T> struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl { using type = decltype(__test<T>(0)); };
	template <typename T> struct __is_swappable : public __is_swappable_impl<T>::type {};
	template <typename T> struct __is_nothrow_swappable : public __is_nothrow_swappable_impl<T>::type {};
	template <typename T> struct is_swappable : public __is_swappable_impl<T>::type { ARGCHK(T); };
	template <typename T> struct is_nothrow_swappable : public __is_nothrow_swappable_impl<T>::type { ARGCHK(T); };
	template <typename T> inline constexpr bool is_swappable_v = is_swappable<T>::value;
	template <typename T> inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<T>::value;
	namespace __swappable_with_details
	{
		using std::swap;
		struct __do_is_swappable_with_impl { template <typename T, typename U, typename = decltype(swap(declval<T>(), declval<U>())), typename = decltype(swap(declval<U>(), declval<T>()))> static true_type __test(int); template <typename, typename> static false_type __test(...); };
		struct __do_is_nothrow_swappable_with_impl { template <typename T, typename U> static __bool_constant<noexcept(swap(declval<T>(), declval<U>())) && noexcept(swap(declval<U>(), declval<T>()))> __test(int); template <typename, typename> static false_type __test(...); };
	}
	template <typename T, typename U> struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl { using type = decltype(__test <T, U> (0)); };
	template <typename T> struct __is_swappable_with_impl<T &, T &> : public __swappable_details::__do_is_swappable_impl { using type = decltype(__test <T &> (0)); };
	template <typename T, typename U> struct __is_nothrow_swappable_with_impl : public __swappable_with_details::__do_is_nothrow_swappable_with_impl { using type = decltype(__test <T, U> (0)); };
	template <typename T> struct __is_nothrow_swappable_with_impl<T &, T &> : public __swappable_details::__do_is_nothrow_swappable_impl { using type = decltype(__test <T &> (0)); };
	template <typename T, typename U> struct is_swappable_with : public __is_swappable_with_impl<T, U>::type { ARGCHK(T);  ARGCHK(U); };
	template <typename T, typename U> struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl<T, U>::type { ARGCHK(T); ARGCHK(U); };
	template <typename T, typename U> inline constexpr bool is_swappable_with_v = is_swappable_with<T, U>::value;
	template <typename T, typename U> inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<T, U>::value;
	template <typename RST, typename RTT, bool = is_void<RTT>::value, typename = void> struct __is_invocable_impl : false_type { using __nothrow_conv = false_type; };
	template <typename RST, typename RTT> struct __is_invocable_impl<RST, RTT, true, __void_t<typename RST::type>> : true_type { using __nothrow_conv = true_type; };
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
	template <typename RST, typename RTT> struct __is_invocable_impl<RST, RTT, false, __void_t<typename RST::type>>
	{
		private: using __result_t = typename RST::type;
		static __result_t __get() noexcept;
		template <typename T> static void __conv(__type_identity_t <T>) noexcept;
		template <typename T, bool NTB = noexcept(__conv<T>(__get())), typename = decltype(__conv<T>(__get())), bool DB = false> static __bool_constant<NTB && !DB> __test(int);
		template <typename T, bool = false> static false_type __test(...);
		public: using type = decltype(__test<RTT, true>(1)); using __nothrow_conv = decltype(__test<RTT>(1));
	};
	#pragma GCC diagnostic pop
	template <typename F2, typename...Args> struct __is_invocable : __is_invocable_impl<__invoke_result<F2, Args...>, void>::type {};
	template <typename F2, typename T, typename...Args> constexpr bool __call_is_nt(__invoke_memfun_ref) { using U = typename __inv_unwrap<T>::type; return noexcept((declval<U>().*declval<F2>())(declval<Args>()...)); }
	template <typename F2, typename T, typename...Args> constexpr bool __call_is_nt(__invoke_memfun_deref) { return noexcept(((*declval<T>()).*declval<F2>())(declval<Args>()...)); }
	template <typename F2, typename T> constexpr bool __call_is_nt(__invoke_memobj_ref) { using U = typename __inv_unwrap<T>::type; return noexcept(declval<U>().*declval<F2>()); }
	template <typename F2, typename T> constexpr bool __call_is_nt(__invoke_memobj_deref) { return noexcept((*declval<T>()).*declval<F2>()); }
	template <typename F2, typename...Args> constexpr bool __call_is_nt(__invoke_other) { return noexcept(declval<F2>()(declval<Args>()...)); }
	template <typename RST, typename F2, typename...Args> struct __call_is_nothrow : __bool_constant<__call_is_nt<F2, Args...> (typename RST::__invoke_type {})> {};
	template <typename F2, typename...Args> using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<F2, Args...>, F2, Args...>;
	template <typename F2, typename...Args> struct __is_nothrow_invocable: __and_<__is_invocable<F2, Args...>, __call_is_nothrow_<F2, Args...>>::type {};
	#pragma GCC diagnostic push 
    #pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
	struct __nonesuchbase {};
	struct __nonesuch : private __nonesuchbase { ~__nonesuch() = delete; __nonesuch(__nonesuch const & ) = delete; void operator = (__nonesuch const & ) = delete; };
	#pragma GCC diagnostic pop 
    template <typename FT, typename...Args> struct invoke_result: public __invoke_result<FT, Args...> { ARGCHK(FT); ARGSCHK; };
	template <typename F2, typename...Args> using invoke_result_t = typename invoke_result<F2, Args...>::type;
	template <typename F2, typename...Args> struct is_invocable: __is_invocable_impl<__invoke_result<F2, Args...>, void>::type { ARGCHK(F2); ARGSCHK; };
	template <typename RTT, typename F2, typename...Args> struct is_invocable_r: __is_invocable_impl<__invoke_result<F2, Args...>, RTT>::type { ARGCHK(F2); ARGSCHK; ARGCHK(RTT); };
	template <typename F2, typename...Args> struct is_nothrow_invocable: __and_<__is_invocable_impl <__invoke_result<F2, Args...>, void>, __call_is_nothrow_<F2, Args...>>::type { ARGCHK(F2); ARGSCHK; };
	template <typename RST, typename RTT> using __is_nt_invocable_impl = typename __is_invocable_impl<RST, RTT>::__nothrow_conv;
	template <typename RTT, typename F2, typename...Args> struct is_nothrow_invocable_r: __and_<__is_nt_invocable_impl <__invoke_result<F2, Args...>, RTT>, __call_is_nothrow_<F2, Args...>>::type { ARGCHK(F2); ARGSCHK; ARGCHK(RTT); };
	template <typename T> inline constexpr bool is_void_v = is_void<T>::value;
	template <typename T> inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;
	template <typename T> inline constexpr bool is_integral_v = is_integral<T>::value;
	template <typename T> inline constexpr bool is_floating_point_v = is_floating_point<T>::value;
	template <typename T> inline constexpr bool is_array_v = false;
	template <typename T> inline constexpr bool is_array_v<T[]> = true;
	template <typename T, size_t N> inline constexpr bool is_array_v<T[N]> = true;
	template <typename T> inline constexpr bool is_pointer_v = is_pointer<T>::value;
	template <typename T> inline constexpr bool is_lvalue_reference_v = false;
	template <typename T> inline constexpr bool is_lvalue_reference_v<T &> = true;
	template <typename T> inline constexpr bool is_rvalue_reference_v = false;
	template <typename T> inline constexpr bool is_rvalue_reference_v<T &&> = true;
	template <typename T> inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<T>::value;
	template <typename T> inline constexpr bool is_member_function_pointer_v = is_member_function_pointer<T>::value;
	template <typename T> inline constexpr bool is_enum_v = __is_enum(T);
	template <typename T> inline constexpr bool is_union_v = __is_union(T);
	template <typename T> inline constexpr bool is_class_v = __is_class(T);
	template <typename T> inline constexpr bool is_reference_v = false;
	template <typename T> inline constexpr bool is_reference_v<T&> = true;
	template <typename T> inline constexpr bool is_reference_v<T&&> = true;
	template <typename T> inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;
	template <typename T> inline constexpr bool is_fundamental_v = is_fundamental<T>::value;
	template <typename T> inline constexpr bool is_object_v = is_object<T>::value;
	template <typename T> inline constexpr bool is_scalar_v = is_scalar<T>::value;
	template <typename T> inline constexpr bool is_compound_v = !is_fundamental_v<T>;
	template <typename T> inline constexpr bool is_member_pointer_v = is_member_pointer<T>::value;
	template <typename T> inline constexpr bool is_const_v = false;
	template <typename T> inline constexpr bool is_const_v<const T> = true;
	template <typename T> inline constexpr bool is_function_v = !is_const_v <const T>;
	template <typename T> inline constexpr bool is_function_v<T &> = false;
	template <typename T> inline constexpr bool is_function_v<T &&> = false;
	template <typename T> inline constexpr bool is_volatile_v = false;
	template <typename T> inline constexpr bool is_volatile_v<volatile T> = true;
	template <typename T> inline constexpr bool is_trivial_v = __is_trivial(T);
	template <typename T> inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(T);
	template <typename T> inline constexpr bool is_standard_layout_v = __is_standard_layout(T);
	template <typename T> inline constexpr bool is_empty_v = __is_empty(T);
	template <typename T> inline constexpr bool is_polymorphic_v = __is_polymorphic(T);
	template <typename T> inline constexpr bool is_abstract_v = __is_abstract(T);
	template <typename T> inline constexpr bool is_final_v = __is_final(T);
	template <typename T> inline constexpr bool is_signed_v = is_signed<T>::value;
	template <typename T> inline constexpr bool is_unsigned_v = is_unsigned<T>::value;
	template <typename T, typename...Args> inline constexpr bool is_constructible_v = __is_constructible(T, Args...);
	template <typename T> inline constexpr bool is_default_constructible_v = __is_constructible(T);
	template <typename T> inline constexpr bool is_copy_constructible_v = __is_constructible(T, __add_lval_ref_t<const T>);
	template <typename T> inline constexpr bool is_move_constructible_v = __is_constructible(T, __add_rval_ref_t<T>);
	template <typename T, typename U> inline constexpr bool is_assignable_v = __is_assignable(T, U);
	template <typename T> inline constexpr bool is_copy_assignable_v = __is_assignable(__add_lval_ref_t<T>, __add_lval_ref_t<const T>);
	template <typename T> inline constexpr bool is_move_assignable_v = __is_assignable(__add_lval_ref_t<T>, __add_rval_ref_t<T>);
	template <typename T> inline constexpr bool is_destructible_v = is_destructible<T>::value;
	template <typename T, typename...Args> inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(T, Args...);
	template <typename T> inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(T);
	template <typename T> inline constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(T, __add_lval_ref_t<const T>);
	template <typename T> inline constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(T, __add_rval_ref_t<T>);
	template <typename T, typename U> inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(T, U);
	template <typename T> inline constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(__add_lval_ref_t<T>, __add_lval_ref_t<const T>);
	template <typename T> inline constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(__add_lval_ref_t<T>, __add_rval_ref_t<T>);
	template <typename T> inline constexpr bool is_trivially_destructible_v = false;
	template <typename T> inline constexpr bool is_trivially_destructible_v<T &> = true;
	template <typename T> inline constexpr bool is_trivially_destructible_v<T &&> = true;
	template <typename T, size_t N> inline constexpr bool is_trivially_destructible_v<T[N]> = is_trivially_destructible_v<T>;
	template <typename T, typename...Args> inline constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(T, Args...);
	template <typename T> inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(T);
	template <typename T> inline constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(T, __add_lval_ref_t<const T> );
	template <typename T> inline constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(T, __add_rval_ref_t<T> );
	template <typename T, typename U> inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(T, U);
	template <typename T> inline constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<T>, __add_lval_ref_t<const T>);
	template <typename T> inline constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t<T>, __add_rval_ref_t<T>);
	template <typename T> inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<T>::value;
	template <typename T> inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(T);
	template <typename T> inline constexpr size_t alignment_of_v = alignment_of<T>::value;
	template <typename T> inline constexpr size_t rank_v = 0;
	template <typename T, size_t S> inline constexpr size_t rank_v<T[S]> = 1 + rank_v<T>;
	template <typename T> inline constexpr size_t rank_v<T[]> = 1 + rank_v<T>;
	template <typename T, unsigned Is = 0> inline constexpr size_t extent_v = 0;
	template <typename T, size_t S> inline constexpr size_t extent_v<T[S], 0> = S;
	template <typename T, unsigned Is, size_t S> inline constexpr size_t extent_v<T[S], Is> = extent_v<T, Is - 1>;
	template <typename T> inline constexpr size_t extent_v<T[], 0> = 0;
	template <typename T, unsigned Is> inline constexpr size_t extent_v<T[], Is> = extent_v<T, Is - 1>;
	template <typename T, typename U> inline constexpr bool is_same_v = false;
	template <typename T> inline constexpr bool is_same_v<T, T> = true;
	template <typename BT, typename DT> inline constexpr bool is_base_of_v = __is_base_of(BT, DT);
	template <typename FT, typename TT> inline constexpr bool is_convertible_v = is_convertible<FT, TT>::value;
	template <typename F2, typename...Args> inline constexpr bool is_invocable_v = is_invocable<F2, Args...>::value;
	template <typename F2, typename...Args> inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<F2, Args...>::value;
	template <typename RTT, typename F2, typename...Args> inline constexpr bool is_invocable_r_v = is_invocable_r<RTT, F2, Args...>::value;
	template <typename RTT, typename F2, typename...Args> inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<RTT, F2, Args...>::value;
	template <typename T> struct has_unique_object_representations : bool_constant<__has_unique_object_representations(remove_cv_t <remove_all_extents_t <T>> )> { ARGCHK(T); };
	template <typename T> inline constexpr bool has_unique_object_representations_v = has_unique_object_representations<T>::value;
	template <typename T> struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t <T>)> {};
	template <typename T> inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t <T>);
	template <typename T> struct remove_cvref { using type = typename remove_cv<T>::type; };
	template <typename T> struct remove_cvref<T&> { using type = typename remove_cv<T>::type; };
	template <typename T> struct remove_cvref<T&&> { using type = typename remove_cv<T>::type; };
	template <typename T> using remove_cvref_t = typename remove_cvref<T>::type;
	template <typename T> struct type_identity { using type = T; };
	template <typename T> using type_identity_t = typename type_identity<T>::type;
	template <typename T> struct unwrap_reference { using type = T; };
	template <typename T> struct unwrap_reference<reference_wrapper<T>> { using type = T&; };
	template <typename T> using unwrap_reference_t = typename unwrap_reference<T>::type;
	template <typename T> struct unwrap_ref_decay { using type = unwrap_reference_t<decay_t<T>>; };
	template <typename T> using unwrap_ref_decay_t = typename unwrap_ref_decay<T>::type;
	template <typename T> inline constexpr bool is_bounded_array_v = false;
	template <typename T, size_t S> inline constexpr bool is_bounded_array_v<T[S]> = true;
	template <typename T> inline constexpr bool is_unbounded_array_v = false;
	template <typename T> inline constexpr bool is_unbounded_array_v<T[]> = true;
	template <typename T> struct is_bounded_array : public bool_constant<is_bounded_array_v<T>> {};
	template <typename T> struct is_unbounded_array : public bool_constant<is_unbounded_array_v<T>> {};
	template <typename FT, typename TT> using __copy_cv = typename __match_cv_qualifiers<FT, TT>::__type;
	template <typename X, typename Y> using __cond_res = decltype(false ? declval<X(&)()>()() : declval<Y(&)()>()());
	template <typename A, typename B, typename = void> struct __common_ref_impl {};
	template <typename A, typename B> using __common_ref = typename __common_ref_impl<A, B>::type;
	template <typename X, typename Y> using __condres_cvref = __cond_res<__copy_cv<X, Y> &, __copy_cv<Y, X> &>;
	template <typename X, typename Y> struct __common_ref_impl<X&, Y&, __void_t<__condres_cvref<X, Y>>> : enable_if<is_reference_v<__condres_cvref <X, Y>>, __condres_cvref<X, Y>> {};
	template <typename X, typename Y> using __common_ref_C = remove_reference_t<__common_ref<X&, Y&>> &&;
	template <typename X, typename Y> struct __common_ref_impl<X&&, Y&&, __require_all<is_convertible<X&&, __common_ref_C<X, Y>>, is_convertible<Y&&, __common_ref_C<X, Y>>>> { using type = __common_ref_C<X, Y>; };
	template <typename X, typename Y> using __common_ref_D = __common_ref<X const&, Y&>;
	template <typename X, typename Y> struct __common_ref_impl<X&&, Y&, __require_all<is_convertible<X&&, __common_ref_D<X, Y>>>> { using type = __common_ref_D<X, Y>; };
	template <typename X, typename Y> struct __common_ref_impl<X&, Y&&>: __common_ref_impl<Y&&, X&> {};
	template <typename T, typename U, template <typename> class QT, template <typename> class UQT> struct basic_common_reference {};
	template <typename T> struct __xref { template <typename U> using __type = __copy_cv<T, U>; };
	template <typename T> struct __xref<T&> { template <typename U> using __type = __copy_cv<T, U>&; };
	template <typename T> struct __xref<T&&> { template <typename U> using __type = __copy_cv<T, U>&&; };
	template <typename T1, typename T2> using __basic_common_ref = typename basic_common_reference<remove_cvref_t<T1>, remove_cvref_t<T2>, __xref<T1>::template __type, __xref<T2>::template __type>::type;
	template <typename...T> struct common_reference;
	template <typename...T> using common_reference_t = typename common_reference<T...>::type;
	template <> struct common_reference<> {};
	template <typename T0> struct common_reference<T0> { using type = T0; };
	template <typename T1, typename T2, int BV = 1, typename = void> struct __common_reference_impl: __common_reference_impl<T1, T2, BV + 1> {};
	template <typename T1, typename T2> struct common_reference<T1, T2>: __common_reference_impl<T1, T2> {};
	template <typename T1, typename T2> struct __common_reference_impl<T1&, T2&, 1, void_t<__common_ref <T1&, T2&>>> { using type = __common_ref<T1&, T2&>; };
	template <typename T1, typename T2> struct __common_reference_impl<T1&&, T2&&, 1, void_t<__common_ref <T1&&, T2&&>>> { using type = __common_ref<T1&&, T2&&>; };
	template <typename T1, typename T2> struct __common_reference_impl<T1&, T2&&, 1, void_t<__common_ref <T1&, T2&&>>> { using type = __common_ref<T1&, T2&&>; };
	template <typename T1, typename T2> struct __common_reference_impl<T1&&, T2&, 1, void_t<__common_ref <T1&&, T2&>>> { using type = __common_ref<T1&&, T2&>; };
	template <typename T1, typename T2> struct __common_reference_impl<T1, T2, 2, void_t<__basic_common_ref <T1, T2>>> { using type = __basic_common_ref<T1, T2>; };
	template <typename T1, typename T2> struct __common_reference_impl<T1, T2, 3, void_t<__cond_res <T1, T2>>> { using type = __cond_res<T1, T2>; };
	template <typename T1, typename T2> struct __common_reference_impl<T1, T2, 4, void_t<common_type_t <T1, T2>>> { using type = common_type_t<T1, T2>; };
	template <typename T1, typename T2> struct __common_reference_impl<T1, T2, 5, void> {};
	template <typename T1, typename T2, typename...Ts> struct common_reference<T1, T2, Ts...> : __common_type_fold<common_reference <T1, T2>, __common_type_pack<Ts...>> {};
	template <typename T1, typename T2, typename...Ts> struct __common_type_fold<common_reference <T1, T2>, __common_type_pack<Ts...>, void_t<common_reference_t <T1, T2>>> : public common_reference<common_reference_t <T1, T2>, Ts...> {};
	template<typename T> struct __is_nonvolatile_trivially_copyable { enum { __value = __is_trivially_copyable(T) }; };
	template<typename T> struct __is_nonvolatile_trivially_copyable<volatile T> { enum { __value = 0 }; };
	template<typename OIT, typename IIT> struct __memcpyable { enum { __value = 0 }; };
	template<typename T> struct __memcpyable<T*, T*> : __is_nonvolatile_trivially_copyable<T> {};
	template<typename T> struct __memcpyable<T*, const T*> : __is_nonvolatile_trivially_copyable<T> {};
	template<typename T> constexpr inline bool __is_nonvolatile_trivially_copyable_v = __is_nonvolatile_trivially_copyable<T>::__value;
	constexpr bool is_constant_evaluated() noexcept { return __builtin_is_constant_evaluated(); }
	using ::ptrdiff_t;
	using ::size_t;
	using ::nullptr_t;
}
#endif
