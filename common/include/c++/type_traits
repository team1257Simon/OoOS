#ifndef __TYPETRAITS
#define __TYPETRAITS
// Credit goes to the GNU project for these implementations
// GCC / glibcxx is under the GPL
namespace std
{
    #ifndef _GCC_STDINT_H
    #include "stdint.h"
    #endif
    #include "stddef.h"
	template <typename T> 
	class reference_wrapper;
	template <typename T, T __v> 
	struct integral_constant
	{
		static constexpr T value = __v;
		using value_type = T;
		using type = integral_constant <T, __v>;
		constexpr operator value_type() const noexcept { return value; }
		constexpr value_type operator()() const noexcept { return value; }
	};
	template <bool __v> 
	using __bool_constant = integral_constant <bool, __v>;
	using true_type = __bool_constant <true>;
	using false_type = __bool_constant <false>;
	template <bool __v> using bool_constant = __bool_constant <__v>;
	template <bool, typename T = void> struct enable_if {};
	template <typename T> struct enable_if <true, T> { using type = T; };
	template <bool CT, typename T = void> using __enable_if_t = typename enable_if <CT, T>::type;
	template <bool> struct __conditional { template <typename T, typename>	using type = T; };
	template <>  struct __conditional <false> { template <typename, typename U> using type = U; };
	template <bool CT, typename TT, typename FT> 
	using __conditional_t = typename __conditional <CT>::template type <TT, FT>;
	template <typename T>  struct __type_identity { using type = T; };
	template <typename T>  using __type_identity_t = typename __type_identity <T>::type;
	namespace __detail
	{
		template <typename T, typename...> using __first_t = T;
		template <typename..._Bn> auto __or_fn(int) -> __first_t <false_type, __enable_if_t <!bool(_Bn::value)> ...>;
		template <typename..._Bn> auto __or_fn(...) -> true_type;
		template <typename..._Bn> auto __and_fn(int) -> __first_t <true_type, __enable_if_t <bool(_Bn::value)> ...>;
		template <typename..._Bn> auto __and_fn(...) -> false_type;
	}
	template <typename..._Bn> 
    struct __or_: decltype(__detail::__or_fn <_Bn...> (0)) {};
	template <typename..._Bn> 
    struct __and_: decltype(__detail::__and_fn <_Bn...> (0)) {};
	template <typename _Pp> 
    struct __not_: __bool_constant <!bool(_Pp::value)> {};
	template <typename..._Bn> inline constexpr bool __or_v = __or_ <_Bn...>::value;
	template <typename..._Bn> inline constexpr bool __and_v = __and_ <_Bn...>::value;
	namespace __detail
	{
		template <typename, typename _B1, typename..._Bn> 
		struct __disjunction_impl
		{
			using type = _B1;
		};
		template <typename _B1, typename _B2, typename..._Bn> 
		struct __disjunction_impl <__enable_if_t <!bool(_B1::value)>, _B1, _B2, _Bn...>
		{
			using type = typename __disjunction_impl <void, _B2, _Bn...>::type;
		};
		template <typename, typename _B1, typename..._Bn> 
		struct __conjunction_impl
		{
			using type = _B1;
		};
		template <typename _B1, typename _B2, typename..._Bn> 
		struct __conjunction_impl <__enable_if_t <bool(_B1::value)>, _B1, _B2, _Bn...>
		{
			using type = typename __conjunction_impl <void, _B2, _Bn...>::type;
		};
	}
	template <typename..._Bn> 
	struct conjunction: __detail::__conjunction_impl <void, _Bn...>::type {};
	template <> 
	struct conjunction <>: true_type {};
	template <typename..._Bn> 
	struct disjunction: __detail::__disjunction_impl <void, _Bn...>::type {};
	template <> 
	struct disjunction <>: false_type {};
	template <typename _Pp> 
	struct negation: __not_ <_Pp>::type {};
	template <typename..._Bn> inline constexpr bool conjunction_v = conjunction <_Bn...>::value;
	template <typename..._Bn> inline constexpr bool disjunction_v = disjunction <_Bn...>::value;
	template <typename _Pp> inline constexpr bool negation_v = negation <_Pp>::value;
	template <typename> 
	struct is_reference;
	template <typename> 
	struct is_function;
	template <typename> 
	struct is_void;
	template <typename> 
	struct remove_cv;
	template <typename> 
	struct is_const;
	template <typename> 
	struct __is_array_unknown_bounds;
	template <typename T, size_t = sizeof(T)> constexpr true_type __is_complete_or_unbounded(__type_identity <T> )
	{
		return {};
	}
	template <typename _TypeIdentity, typename _NestedType = typename _TypeIdentity::type> constexpr typename __or_ <is_reference <_NestedType>, is_function <_NestedType>, is_void <_NestedType>, __is_array_unknown_bounds <_NestedType>>::type __is_complete_or_unbounded(_TypeIdentity)
	{
		return {};
	}
	template <typename T> 
	using __remove_cv_t = typename remove_cv <T>::type;
	template <typename T> 
	struct is_void: public false_type {};
	template <> 
	struct is_void <void>: public true_type {};
	template <> 
	struct is_void <const void>: public true_type {};
	template <> 
	struct is_void <volatile void>: public true_type {};
	template <> 
	struct is_void <const volatile void>: public true_type {};
	template <typename> 
	struct __is_integral_helper: public false_type {};
	template <> 
	struct __is_integral_helper <bool>: public true_type {};
	template <> 
	struct __is_integral_helper <char>: public true_type {};
	template <> 
	struct __is_integral_helper <signed char>: public true_type {};
	template <> 
	struct __is_integral_helper <unsigned char>: public true_type {};
	template <> 
	struct __is_integral_helper <wchar_t>: public true_type {};
	template <> 
	struct __is_integral_helper <char16_t>: public true_type {};
	template <> 
	struct __is_integral_helper <char32_t>: public true_type {};
	template <> 
	struct __is_integral_helper <short>: public true_type {};
	template <> 
	struct __is_integral_helper <unsigned short>: public true_type {};
	template <> 
	struct __is_integral_helper <int>: public true_type {};
	template <> 
	struct __is_integral_helper <unsigned int>: public true_type {};
	template <> 
	struct __is_integral_helper <long>: public true_type {};
	template <> 
	struct __is_integral_helper <unsigned long>: public true_type {};
	template <> 
	struct __is_integral_helper <long long>: public true_type {};
	template <> 
	struct __is_integral_helper <unsigned long long>: public true_type {};
	template <typename T> 
	struct is_integral: public __is_integral_helper <__remove_cv_t <T>>::type {};
	template <typename> 
	struct __is_floating_point_helper: public false_type {};
	template <> 
	struct __is_floating_point_helper <float>: public true_type {};
	template <> 
	struct __is_floating_point_helper <double>: public true_type {};
	template <> 
	struct __is_floating_point_helper <long double>: public true_type {};
	template <typename T> 
	struct is_floating_point: public __is_floating_point_helper <__remove_cv_t <T>>::type {};
	template <typename> 
	struct is_array: public false_type {};
	template <typename T, size_t S> 
	struct is_array <T[S]>: public true_type {};
	template <typename T> 
	struct is_array <T[]>: public true_type {};
	template <typename> 
	struct __is_pointer_helper: public false_type {};
	template <typename T> 
	struct __is_pointer_helper <T *>: public true_type {};
	template <typename T> 
	struct is_pointer: public __is_pointer_helper <__remove_cv_t <T>>::type {};
	template <typename> 
	struct is_lvalue_reference: public false_type {};
	template <typename T> 
	struct is_lvalue_reference <T &>: public true_type {};
	template <typename> 
	struct is_rvalue_reference: public false_type {};
	template <typename T> 
	struct is_rvalue_reference <T &&>: public true_type {};
	template <typename> 
	struct __is_member_object_pointer_helper: public false_type {};
	template <typename T, typename _Cp> 
	struct __is_member_object_pointer_helper <T _Cp:: *>: public __not_ <is_function <T>>::type {};
	template <typename T> 
	struct is_member_object_pointer: public __is_member_object_pointer_helper <__remove_cv_t <T>>::type {};
	template <typename> 
	struct __is_member_function_pointer_helper: public false_type {};
	template <typename T, typename _Cp> 
	struct __is_member_function_pointer_helper <T _Cp:: *>: public is_function <T>::type {};
	template <typename T> 
	struct is_member_function_pointer: public __is_member_function_pointer_helper <__remove_cv_t <T>>::type {};
	template <typename T> 
	struct is_enum: public __bool_constant <__is_enum(T)> {};
	template <typename T> 
	struct is_union: public __bool_constant <__is_union(T)> {};
	template <typename T> 
	struct is_class: public __bool_constant <__is_class(T)> {};
	template <typename T> 
	struct is_function: public __bool_constant <!is_const <const T>::value> {};
	template <typename T> 
	struct is_function <T &>: public false_type {};
	template <typename T> 
	struct is_function <T &&>: public false_type {};
	template <typename T> 
	struct is_reference: public false_type {};
	template <typename T> 
	struct is_reference <T &>: public true_type {};
	template <typename T> 
	struct is_reference <T &&>: public true_type {};
    template <typename T>
    struct is_null_pointer : public false_type { };
    template <> 
	struct is_null_pointer <nullptr_t>: public true_type { };
    template <> 
	struct is_null_pointer <const nullptr_t>: public true_type { };
    template <> 
	struct is_null_pointer <volatile nullptr_t>: public true_type { };
    template <> 
	struct is_null_pointer <const volatile nullptr_t>: public true_type { };
	template <typename T> 
	struct is_arithmetic: public __or_ <is_integral <T>, is_floating_point <T>>::type {};
	template <typename T> 
	struct is_fundamental: public __or_ <is_arithmetic <T>, is_void <T>, is_null_pointer <T>>::type {};
	template <typename T> 
	struct is_object: public __not_ <__or_ <is_function <T>, is_reference <T>, is_void <T>>>::type {};
	template <typename> 
	struct is_member_pointer;
	template <typename T> 
	struct is_scalar: public __or_ <is_arithmetic <T>, is_enum <T>, is_pointer <T>, is_member_pointer <T>, is_null_pointer <T>>::type {};
	template <typename T> 
	struct is_compound: public __bool_constant <!is_fundamental <T>::value> {};
	template <typename T> 
	struct __is_member_pointer_helper: public false_type {};
	template <typename T, typename _Cp> 
	struct __is_member_pointer_helper <T _Cp:: *>: public true_type {};
	template <typename T> 
	struct is_member_pointer: public __is_member_pointer_helper <__remove_cv_t <T>>::type {};
	template <typename, typename> 
	struct is_same;
	template <typename T, typename...Ts> 
	using __is_one_of = __or_ <is_same <T, Ts> ...>;
	__extension__ 
	template <typename T> 
	using __is_signed_integer = __is_one_of <__remove_cv_t <T>, signed char, signed short, signed int, signed long, signed long long>;
	__extension__ 
	template <typename T> 
	using __is_unsigned_integer = __is_one_of <__remove_cv_t <T>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
	template <typename T> 
	using __is_standard_integer = __or_ <__is_signed_integer <T>, __is_unsigned_integer <T>>;
	template <typename...> 
	using __void_t = void;
	template <typename> 
	struct is_const: public false_type {};
	template <typename T> 
	struct is_const <T const>: public true_type {};
	template <typename> 
	struct is_volatile: public false_type {};
	template <typename T> 
	struct is_volatile <T volatile>: public true_type {};
	template <typename T> 
	struct is_trivial: public __bool_constant <__is_trivial(T)>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_trivially_copyable: public __bool_constant <__is_trivially_copyable(T)>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_standard_layout: public __bool_constant <__is_standard_layout(T)>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
    struct is_empty: public __bool_constant <__is_empty(T)> {};
	template <typename T> 
    struct is_polymorphic: public __bool_constant <__is_polymorphic(T)> {};
	template <typename T> 
    struct is_final: public __bool_constant <__is_final(T)> {};
	template <typename T> 
    struct is_abstract: public __bool_constant <__is_abstract(T)> {};
	template <typename T, bool = is_arithmetic <T>::value> 
    struct __is_signed_helper: public false_type {};
	template <typename T> 
    struct __is_signed_helper <T, true>: public __bool_constant <T(-1) < T(0)> {};
	template <typename T> 
    struct is_signed: public __is_signed_helper <T>::type {};
	template <typename T> 
    struct is_unsigned: public __and_ <is_arithmetic <T>, __not_ <is_signed <T>>>::type {};
	template <typename T, typename U = T&&>
	U __declval(int);
	template <typename T> 
	T __declval(long);
	template <typename T> 
	auto declval() noexcept -> decltype(__declval <T> (0));
	template <typename> 
	struct remove_all_extents;
	template <typename T> 
	struct __is_array_known_bounds: public false_type {};
	template <typename T, size_t S> 
	struct __is_array_known_bounds <T[S]>: public true_type {};
	template <typename T> 
	struct __is_array_unknown_bounds: public false_type {};
	template <typename T> 
	struct __is_array_unknown_bounds <T[]>: public true_type {};
	struct __do_is_destructible_impl
	{
		template <typename T, typename = decltype(declval <T &> ().~T())> 
		static true_type __test(int);
		template <typename> static false_type 
		__test(...);
	};
	template <typename T> 
	struct __is_destructible_impl: public __do_is_destructible_impl
	{
		using type = decltype(__test <T> (0));
	};
	template <typename T, bool = __or_ <is_void <T>, __is_array_unknown_bounds <T>, is_function <T>>::value, bool = __or_ <is_reference <T>, is_scalar <T>>::value> 
	struct __is_destructible_safe;
	template <typename T> 
	struct __is_destructible_safe <T, false, false>: public __is_destructible_impl <typename remove_all_extents <T>::type>::type {};
	template <typename T> 
	struct __is_destructible_safe <T, true, false>: public false_type {};
	template <typename T> 
	struct __is_destructible_safe <T, false, true>: public true_type {};
	template <typename T> 
	struct is_destructible: public __is_destructible_safe <T>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	struct __do_is_nt_destructible_impl
	{
		template <typename T> static __bool_constant <noexcept(declval <T &> ().~T())> __test(int);
		template <typename> static false_type __test(...);
	};
	template <typename T> 
	struct __is_nt_destructible_impl: public __do_is_nt_destructible_impl
	{
		using type = decltype(__test <T> (0));
	};
	template <typename T, bool = __or_ <is_void <T>, __is_array_unknown_bounds <T>, is_function <T>>::value, bool = __or_ <is_reference <T>, is_scalar <T>>::value> 
	struct __is_nt_destructible_safe;
	template <typename T> 
	struct __is_nt_destructible_safe <T, false, false>: public __is_nt_destructible_impl <typename remove_all_extents <T>::type>::type {};
	template <typename T> 
	struct __is_nt_destructible_safe <T, true, false>: public false_type {};
	template <typename T> 
	struct __is_nt_destructible_safe <T, false, true>: public true_type {};
	template <typename T> 
	struct is_nothrow_destructible: public __is_nt_destructible_safe <T>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename...Args> 
	using __is_constructible_impl = __bool_constant <__is_constructible(T, Args...)>;
	template <typename T, typename...Args> 
	struct is_constructible: public __is_constructible_impl <T, Args...>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_default_constructible: public __is_constructible_impl <T>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename = void> 
	struct __add_lvalue_reference_helper
	{
		using type = T;
	};
	template <typename T> 
	struct __add_lvalue_reference_helper <T, __void_t <T &>>
	{
		using type = T &;
	};
	template <typename T> 
	using __add_lval_ref_t = typename __add_lvalue_reference_helper <T>::type;
	template <typename T> 
	struct is_copy_constructible: public __is_constructible_impl <T, __add_lval_ref_t <const T>>
    {
        static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
    };
	template <typename T, typename = void> 
	struct __add_rvalue_reference_helper
	{
		using type = T;
	};
	template <typename T> 
	struct __add_rvalue_reference_helper <T, __void_t <T &&>>
	{
		using type = T &&;
	};
	template <typename T> 
	using __add_rval_ref_t = typename __add_rvalue_reference_helper <T>::type;
	template <typename T> 
	struct is_move_constructible: public __is_constructible_impl <T, __add_rval_ref_t <T>>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename...Args> 
	using __is_nothrow_constructible_impl = __bool_constant <__is_nothrow_constructible(T, Args...)>;
	template <typename T, typename...Args> 
	struct is_nothrow_constructible: public __is_nothrow_constructible_impl <T, Args...>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_nothrow_default_constructible: public __is_nothrow_constructible_impl <T>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_nothrow_copy_constructible: public __is_nothrow_constructible_impl <T, __add_lval_ref_t <const T>>
    {
        static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
    };
	template <typename T> 
	struct is_nothrow_move_constructible: public __is_nothrow_constructible_impl <T, __add_rval_ref_t <T>>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename U> 
	using __is_assignable_impl = __bool_constant <__is_assignable(T, U)>;
	template <typename T, typename U> 
	struct is_assignable: public __is_assignable_impl <T, U>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_copy_assignable: public __is_assignable_impl <__add_lval_ref_t <T>, __add_lval_ref_t <const T>>
    {
        static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
    };
	template <typename T> 
	struct is_move_assignable: public __is_assignable_impl <__add_lval_ref_t <T>, __add_rval_ref_t <T>>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename U> 
	using __is_nothrow_assignable_impl = __bool_constant <__is_nothrow_assignable(T, U)>;
	template <typename T, typename U> 
	struct is_nothrow_assignable: public __is_nothrow_assignable_impl <T, U>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_nothrow_copy_assignable: public __is_nothrow_assignable_impl <__add_lval_ref_t <T>, __add_lval_ref_t <const T>>
    {
        static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
    };
	template <typename T> 
	struct is_nothrow_move_assignable: public __is_nothrow_assignable_impl <__add_lval_ref_t <T>, __add_rval_ref_t <T>>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename...Args> 
	using __is_trivially_constructible_impl = __bool_constant <__is_trivially_constructible(T, Args...)>;
	template <typename T, typename...Args> 
	struct is_trivially_constructible: public __is_trivially_constructible_impl <T, Args...>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_trivially_default_constructible: public __is_trivially_constructible_impl <T>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	struct __do_is_implicitly_default_constructible_impl
	{
		template <typename T> static void __helper(const T & );
		template <typename T> static true_type __test(const T &, decltype(__helper <const T &> ({})) * = 0);
		static false_type __test(...);
	};
	template <typename T> 
	struct __is_implicitly_default_constructible_impl: public __do_is_implicitly_default_constructible_impl
	{
		using type = decltype(__test(declval <T> ()));
	};
	template <typename T> 
	struct __is_implicitly_default_constructible_safe: public __is_implicitly_default_constructible_impl <T>::type {};
	template <typename T> 
	struct __is_implicitly_default_constructible: public __and_ <__is_constructible_impl <T>, __is_implicitly_default_constructible_safe <T>>::type {};
	template <typename T> 
	struct is_trivially_copy_constructible: public __is_trivially_constructible_impl <T, __add_lval_ref_t <const T>>
    {
        static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
    };
	template <typename T> 
	struct is_trivially_move_constructible: public __is_trivially_constructible_impl <T, __add_rval_ref_t <T>>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename U> 
	using __is_trivially_assignable_impl = __bool_constant <__is_trivially_assignable(T, U)>;
	template <typename T, typename U> 
	struct is_trivially_assignable: public __is_trivially_assignable_impl <T, U>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_trivially_copy_assignable: public __is_trivially_assignable_impl <__add_lval_ref_t <T>, __add_lval_ref_t <const T>>
    {
        static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
    };
	template <typename T> 
	struct is_trivially_move_assignable: public __is_trivially_assignable_impl <__add_lval_ref_t <T>, __add_rval_ref_t <T>>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_trivially_destructible: public __and_ <__is_destructible_safe <T>, __bool_constant <__has_trivial_destructor(T)>>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct has_virtual_destructor: public __bool_constant <__has_virtual_destructor(T)>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct alignment_of: public integral_constant <size_t, alignof(T)>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename> 
	struct rank: public integral_constant <size_t, 0> {};
	template <typename T, size_t S> 
	struct rank <T[S]>: public integral_constant <size_t, 1 + rank <T>::value> {};
	template <typename T> 
	struct rank <T[]>: public integral_constant <size_t, 1 + rank <T>::value> {};
	template <typename, unsigned UI1 = 0> 
	struct extent: public integral_constant <size_t, 0> {};
	template <typename T, size_t S> 
	struct extent <T[S], 0>: public integral_constant <size_t, S> {};
	template <typename T, unsigned UI1, size_t S> 
	struct extent <T[S], UI1>: public extent <T, UI1 - 1>::type {};
	template <typename T> 
	struct extent <T[], 0>: public integral_constant <size_t, 0> {};
	template <typename T, unsigned UI1> 
	struct extent <T[], UI1>: public extent <T, UI1 - 1>::type {};
	template <typename T, typename U> 
	struct is_same: public false_type {};
	template <typename T> 
	struct is_same <T, T>: public true_type {};
	template <typename _Base, typename _Derived> 
	struct is_base_of: public __bool_constant <__is_base_of(_Base, _Derived)> {};
	template <typename FT, typename TT, bool = __or_ <is_void <FT>, is_function <TT>, is_array <TT>>::value> 
	struct __is_convertible_helper
	{
		using type = typename is_void <TT>::type;
	};
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
	template <typename FT, typename TT>
    class __is_convertible_helper <FT, TT, false>
	{
		template <typename _To1> static void __test_aux(_To1) noexcept;
		template <typename _From1, typename _To1, typename = decltype(__test_aux <_To1> (declval <_From1> ()))> static true_type __test(int);
		template <typename, typename> static false_type __test(...);
		public: 
			using type = decltype(__test <FT, TT> (0));
	};
	#pragma GCC diagnostic pop
	template <typename FT, typename TT> 
	struct is_convertible: public __is_convertible_helper <FT, TT>::type {};
	template <typename _ToElementType, typename _FromElementType> 
	using __is_array_convertible = is_convertible <_FromElementType( * )[], _ToElementType( * )[]>;
	template <typename T> 
	struct remove_const
	{
		using type = T;
	};
	template <typename T> 
	struct remove_const <T
	const>
	{
		using type = T;
	};
	template <typename T> 
	struct remove_volatile
	{
		using type = T;
	};
	template <typename T> 
	struct remove_volatile <T volatile>
	{
		using type = T;
	};
	template <typename T> 
	struct remove_cv
	{
		using type = T;
	};
	template <typename T> 
    struct remove_cv <const T>
    {
        using type = T;
    };
	template <typename T> 
    struct remove_cv <volatile T>
	{
		using type = T;
	};
	template <typename T>
    struct remove_cv <const volatile T>
    {
        using type = T;
    };
	template <typename T> 
	struct add_const
	{
		using type = T const;
	};
	template <typename T> 
	struct add_volatile
	{
		using type = T volatile;
	};
	template <typename T> 
	struct add_cv
	{
		using type = T const volatile;
	};
	template <typename T> 
	using remove_const_t = typename remove_const <T>::type;
	template <typename T> 
	using remove_volatile_t = typename remove_volatile <T>::type;
	template <typename T> 
	using remove_cv_t = typename remove_cv <T>::type;
	template <typename T> 
	using add_const_t = typename add_const <T>::type;
	template <typename T> 
	using add_volatile_t = typename add_volatile <T>::type;
	template <typename T> 
	using add_cv_t = typename add_cv <T>::type;
	template <typename T> 
	struct remove_reference
	{
		using type = T;
	};
	template <typename T> 
	struct remove_reference <T &>
	{
		using type = T;
	};
	template <typename T> 
	struct remove_reference <T &&>
	{
		using type = T;
	};
	template <typename T> 
	struct add_lvalue_reference
	{
		using type = __add_lval_ref_t <T>;
	};
	template <typename T> 
	struct add_rvalue_reference
	{
		using type = __add_rval_ref_t <T>;
	};
	template <typename T> 
	using remove_reference_t = typename remove_reference <T>::type;
	template <typename T> 
	using add_lvalue_reference_t = typename add_lvalue_reference <T>::type;
	template <typename T> 
	using add_rvalue_reference_t = typename add_rvalue_reference <T>::type;
	template <typename UQ, bool IC, bool IV> 
	struct __cv_selector;
	template <typename UQ> 
	struct __cv_selector <UQ, false, false>
	{
		using __type = UQ;
	};
	template <typename UQ> 
	struct __cv_selector <UQ, false, true>
	{
		using __type = volatile UQ;
	};
	template <typename UQ> 
	struct __cv_selector <UQ, true, false>
	{
		using __type =
		const UQ;
	};
	template <typename UQ> 
	struct __cv_selector <UQ, true, true>
	{
		using __type =
		const volatile UQ;
	};
	template <typename QT, typename UQ, bool IC = is_const <QT>::value, bool IV = is_volatile <QT>::value> 
	class __match_cv_qualifiers
	{
		using __match = __cv_selector <UQ, IC, IV>;
		public: using __type = typename __match::__type;
	};
	template <typename T> 
    struct __make_unsigned
	{
		using __type = T;
	};
	template <> 
    struct __make_unsigned <char>
	{
		using __type = unsigned char;
	};
	template <>
    struct __make_unsigned <short>
	{
		using __type = unsigned short;
	};
	template <> 
    struct __make_unsigned <int>
	{
		using __type = unsigned int;
	};
	template <> 
    struct __make_unsigned <long>
	{
		using __type = unsigned long;
	};
	template <> 
    struct __make_unsigned <long long>
	{
		using __type = unsigned long long;
	};
	template <typename T, bool II = is_integral <T>::value, bool IE = __is_enum(T)> 
	class __make_unsigned_selector;
	template <typename T> 
	class __make_unsigned_selector <T, true, false>
	{
		using __unsigned_type = typename __make_unsigned <__remove_cv_t <T>>::__type;
		public: using __type = typename __match_cv_qualifiers <T, __unsigned_type>::__type;
	};
	class __make_unsigned_selector_base
	{
		protected: 
		template <typename...> 
		struct __list {};
		template <typename T, typename...U> 
		struct __list <T, U...>: __list <U...>
		{
			static constexpr size_t __size = sizeof(T);
		};
		template <size_t _Sz,
		typename T,
		bool = (_Sz <= T::__size)> 
	struct __select;
		template <size_t _Sz, typename UI1, typename...UIs> 
	struct __select <_Sz, __list <UI1, UIs...>, true>
		{
			using __type = UI1;
		};
		template <size_t _Sz, typename UI1, typename...UIs> 
	struct __select <_Sz, __list <UI1, UIs...>, false>: __select <_Sz, __list <UIs...>> {};
	};
	template <typename T> 
	class __make_unsigned_selector <T, false, true>: __make_unsigned_selector_base
	{
		using UIs = __list <unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
		using __unsigned_type = typename __select <sizeof(T), UIs>::__type;
		public: using __type = typename __match_cv_qualifiers <T, __unsigned_type>::__type;
	};
	template <> 
	struct __make_unsigned <wchar_t>
	{
		using __type = typename __make_unsigned_selector <wchar_t, false, true>::__type;
	};
	template <typename T> 
	struct make_unsigned
	{
		using type = typename __make_unsigned_selector <T>::__type;
	};
	template <> 
	struct make_unsigned <bool>;
	template <> 
	struct make_unsigned <bool const>;
	template <> 
	struct make_unsigned <bool volatile>;
	template <> 
	struct make_unsigned <bool const volatile>;
	template <typename T> 
	struct __make_signed
	{
		using __type = T;
	};
	template <> 
	struct __make_signed <char>
	{
		using __type = signed char;
	};
	template <> 
	struct __make_signed <unsigned char>
	{
		using __type = signed char;
	};
	template <> 
	struct __make_signed <unsigned short>
	{
		using __type = signed short;
	};
	template <> 
	struct __make_signed <unsigned int>
	{
		using __type = signed int;
	};
	template <> 
	struct __make_signed <unsigned long>
	{
		using __type = signed long;
	};
	template <> 
	struct __make_signed <unsigned long long>
	{
		using __type = signed long long;
	};
	template <typename T, bool II = is_integral <T>::value, bool IE = __is_enum(T)> 
	class __make_signed_selector;
	template <typename T> 
	class __make_signed_selector <T, true, false>
	{
		using __signed_type = typename __make_signed <__remove_cv_t <T>>::__type;
		public: using __type = typename __match_cv_qualifiers <T,
		__signed_type>::__type;
	};
	template <typename T> 
	class __make_signed_selector <T, false, true>
	{
		using __unsigned_type = typename __make_unsigned_selector <T>::__type;
		public: using __type = typename __make_signed_selector <__unsigned_type>::__type;
	};
	template <> 
	struct __make_signed <wchar_t>
	{
		using __type = typename __make_signed_selector <wchar_t,
		false,
		true>::__type;
	};
	template <typename T> 
	struct make_signed
	{
		using type = typename __make_signed_selector <T>::__type;
	};
	template <> 
	struct make_signed <bool>;
	template <> 
	struct make_signed <bool const>;
	template <> 
	struct make_signed <bool volatile>;
	template <> 
	struct make_signed <bool const volatile>;
	template <typename T> 
	struct remove_extent
	{
		using type = T;
	};
	template <typename T, size_t S> 
	struct remove_extent <T[S]>
	{
		using type = T;
	};
	template <typename T> 
	struct remove_extent <T[]>
	{
		using type = T;
	};
	template <typename T> 
	struct remove_all_extents
	{
		using type = T;
	};
	template <typename T, size_t S> 
	struct remove_all_extents <T[S]>
	{
		using type = typename remove_all_extents <T>::type;
	};
	template <typename T> 
	struct remove_all_extents <T[]>
	{
		using type = typename remove_all_extents <T>::type;
	};
	template <typename T> 
	using remove_extent_t = typename remove_extent <T>::type;
	template <typename T> 
	using remove_all_extents_t = typename remove_all_extents <T>::type;
	template <typename T, typename> 
	struct __remove_pointer_helper
	{
		using type = T;
	};
	template <typename T, typename U> 
	struct __remove_pointer_helper <T, U *>
	{
		using type = U;
	};
	template <typename T> 
	struct remove_pointer: public __remove_pointer_helper <T, __remove_cv_t <T>> {};
	template <typename T, typename = void> 
	struct __add_pointer_helper
	{
		using type = T;
	};
	template <typename T> 
	struct __add_pointer_helper <T, __void_t <T *>>
	{
		using type = T *;
	};
	template <typename T> 
	struct add_pointer: public __add_pointer_helper <T> {};
	template <typename T> 
	struct add_pointer <T &>
	{
		using type = T *;
	};
	template <typename T> 
	struct add_pointer <T &&>
	{
		using type = T *;
	};
	template <typename T> 
	using remove_pointer_t = typename remove_pointer <T>::type;
	template <typename T> 
	using add_pointer_t = typename add_pointer <T>::type;
	template <size_t __Len> 
	struct __aligned_storage_msa
	{
		union __type
		{
			unsigned char __data[__Len];
			struct __attribute__((__aligned__)) {} __align;
		};
	};
	template <typename...Ts> 
	struct __strictest_alignment
	{
		static
		const size_t __alignment = 0;
		static
		const size_t __size = 0;
	};
	template <typename T, typename...Ts> 
	struct __strictest_alignment <T, Ts...>
	{
		static
		const size_t __alignment = alignof(T)> __strictest_alignment <Ts...>::__alignment ? alignof(T) : __strictest_alignment <Ts...>::__alignment;
		static
		const size_t __size = sizeof(T)> __strictest_alignment <Ts...>::__size ? sizeof(T) : __strictest_alignment <Ts...>::__size;
	};
	template <typename U> 
	struct __decay_selector: __conditional_t <is_const <const U>::value, remove_cv <U>, add_pointer <U>> {};
	template <typename U, size_t _Nm> 
	struct __decay_selector <U[_Nm]>
	{
		using type = U *;
	};
	template <typename U> 
	struct __decay_selector <U[]>
	{
		using type = U *;
	};
	template <typename T> 
	struct decay
	{
		using type = typename __decay_selector <T>::type;
	};
	template <typename T> 
	struct decay <T &>
	{
		using type = typename __decay_selector <T>::type;
	};
	template <typename T> 
	struct decay <T &&>
	{
		using type = typename __decay_selector <T>::type;
	};
	template <typename T> 
	struct __strip_reference_wrapper
	{
		using __type = T;
	};
	template <typename T> 
	struct __strip_reference_wrapper <reference_wrapper <T>>
	{
		using __type = T &;
	};
	template <typename T> 
	using __decay_t = typename decay <T>::type;
	template <typename T> 
	using __decay_and_strip = __strip_reference_wrapper <__decay_t <T>>;
	template <typename...CT> 
	using __require_all = __enable_if_t <__and_ <CT...>::value>;
	template <typename T> 
	using __remove_cvref_t = typename remove_cv <typename remove_reference <T>::type>::type;
	template <bool CT, typename TCT, typename FCT> 
	struct conditional
	{
		using type = TCT;
	};
	template <typename TCT, typename FCT> 
	struct conditional <false, TCT, FCT>
	{
		using type = FCT;
	};
	template <typename...T> 
	struct common_type;
	template <typename T> 
	struct __success_type
	{
		using type = T;
	};
	struct __failure_type {};
	struct __do_common_type_impl
	{
		template <typename T, typename U> 
	using __cond_t = decltype(true ? declval <T> () : declval <U> ());
		template <typename T, typename U> static __success_type <__decay_t <__cond_t <T, U>>> __test(int);
		template <typename T, typename U> static __success_type <__remove_cvref_t <__cond_t <const T &, const U &>>> _S_test_2(int);
		template <typename, typename> static __failure_type _S_test_2(...);
		template <typename T, typename U> static decltype(_S_test_2 <T, U> (0)) __test(...);
	};
	template <> 
	struct common_type <> {};
	template <typename T0> 
	struct common_type <T0>: public common_type <T0, T0> {};
	template <typename T1, typename T2, typename D1 = __decay_t <T1>, typename D2 = __decay_t <T2>> 
	struct __common_type_impl
	{
		using type = common_type <D1, D2>;
	};
	template <typename T1, typename T2> 
	struct __common_type_impl <T1, T2, T1, T2>: private __do_common_type_impl
	{
		using type = decltype(__test <T1, T2> (0));
	};
	template <typename T1, typename T2> 
	struct common_type <T1, T2>: public __common_type_impl <T1, T2>::type {};
	template <typename...> 
	struct __common_type_pack {};
	template <typename, typename, typename = void> 
	struct __common_type_fold;
	template <typename T1, typename T2, typename...PT> 
	struct common_type <T1, T2, PT...>: public __common_type_fold <common_type <T1, T2>, __common_type_pack <PT...>> {};
	template <typename CT, typename...PT> 
	struct __common_type_fold <CT, __common_type_pack <PT...>, __void_t <typename CT::type>>: public common_type <typename CT::type, PT...> {};
	template <typename CT, typename PT> 
	struct __common_type_fold <CT, PT, void> {};
	template <typename T, bool = __is_enum(T)> 
	struct __underlying_type_impl
	{
		using type = __underlying_type(T);
	};
	template <typename T> 
	struct __underlying_type_impl <T, false> {};
	template <typename T> 
	struct underlying_type: public __underlying_type_impl <T> {};
	template <typename T> 
	struct __declval_protector
	{
		static
		const bool __stop = false;
	};
	template <typename T> auto declval() noexcept -> decltype(__declval <T> (0))
	{
		static_assert(__declval_protector <T>::__stop, "declval() must not be used!");
		return __declval <T> (0);
	}
	template <typename S> 
	struct result_of;
	struct __invoke_memfun_ref {};
	struct __invoke_memfun_deref {};
	struct __invoke_memobj_ref {};
	struct __invoke_memobj_deref {};
	struct __invoke_other {};
	template <typename T, typename ST> 
	struct __result_of_success: __success_type <T>
	{
		using __invoke_type = ST;
	};
	struct __result_of_memfun_ref_impl
	{
		template <typename FT, typename T1, typename...Args> static __result_of_success <decltype((declval <T1> ().*declval <FT> ())(declval <Args> ()...)), __invoke_memfun_ref> __test(int);
		template <typename...> static __failure_type __test(...);
	};
	template <typename MPT, typename AT1, typename...Args> 
	struct __result_of_memfun_ref: private __result_of_memfun_ref_impl
	{
		using type = decltype(__test <MPT, AT1, Args...> (0));
	};
	struct __result_of_memfun_deref_impl
	{
		template <typename FT, typename T1, typename...Args> static __result_of_success <decltype((( * declval <T1> ()).*declval <FT> ())(declval <Args> ()...)), __invoke_memfun_deref> __test(int);
		template <typename...> static __failure_type __test(...);
	};
	template <typename MPT, typename AT1, typename...Args> 
	struct __result_of_memfun_deref: private __result_of_memfun_deref_impl
	{
		using type = decltype(__test <MPT, AT1, Args...> (0));
	};
	struct __result_of_memobj_ref_impl
	{
		template <typename FT, typename T1> static __result_of_success <decltype(declval <T1> ().*declval <FT> ()), __invoke_memobj_ref> __test(int);
		template <typename, typename> static __failure_type __test(...);
	};
	template <typename MPT, typename AT1> 
	struct __result_of_memobj_ref: private __result_of_memobj_ref_impl
	{
		using type = decltype(__test <MPT, AT1> (0));
	};
	struct __result_of_memobj_deref_impl
	{
		template <typename FT, typename T1> static __result_of_success <decltype(( * declval <T1> ()).*declval <FT> ()), __invoke_memobj_deref> __test(int);
		template <typename, typename> static __failure_type __test(...);
	};
	template <typename MPT, typename AT1> 
	struct __result_of_memobj_deref: private __result_of_memobj_deref_impl
	{
		using type = decltype(__test <MPT, AT1> (0));
	};
	template <typename MPT, typename AT1> 
	struct __result_of_memobj;
	template <typename R, typename CLT, typename AT1> 
	struct __result_of_memobj <R CLT:: *, AT1>
	{
		using __argval = __remove_cvref_t <AT1>;
		using __mem_ptr = R CLT:: *;
		using type = typename __conditional_t <__or_ <is_same <__argval, CLT>, is_base_of <CLT, __argval>>::value, __result_of_memobj_ref <__mem_ptr, AT1>, __result_of_memobj_deref <__mem_ptr,	AT1>>::type;
	};
	template <typename MPT, typename AT1, typename...Args> 
	struct __result_of_memfun;
	template <typename R, typename CLT, typename AT1, typename...Args> 
	struct __result_of_memfun <R CLT:: *, AT1, Args...>
	{
		using __argval = typename remove_reference <AT1>::type;
		using __mem_ptr = R CLT:: *;
		using type = typename __conditional_t <is_base_of <CLT, __argval>::value, __result_of_memfun_ref <__mem_ptr, AT1, Args...>, __result_of_memfun_deref <__mem_ptr, AT1, Args...>>::type;
	};
	template <typename T, typename U = __remove_cvref_t <T>> 
	struct __inv_unwrap
	{
		using type = T;
	};
	template <typename T, typename U> 
	struct __inv_unwrap <T, reference_wrapper <U>>
	{
		using type = U &;
	};
	template <bool, bool, typename FT, typename...Args> 
	struct __result_of_impl
	{
		using type = __failure_type;
	};
	template <typename MPT, typename AT1> 
	struct __result_of_impl <true, false, MPT, AT1>: public __result_of_memobj <__decay_t <MPT>, typename __inv_unwrap <AT1>::type> {};
	template <typename MPT, typename AT1, typename...Args> 
	struct __result_of_impl <false, true, MPT, AT1, Args...>: public __result_of_memfun <__decay_t <MPT>, typename __inv_unwrap <AT1>::type, Args...> {};
	struct __result_of_other_impl
	{
		template <typename F2, typename...Args> static __result_of_success <decltype(declval <F2> ()(declval <Args> ()...)), __invoke_other> __test(int);
		template <typename...> static __failure_type __test(...);
	};
	template <typename FT, typename...Args> 
	struct __result_of_impl <false, false, FT, Args...>: private __result_of_other_impl
	{
		using type = decltype(__test <FT, Args...> (0));
	};
	template <typename FT, typename...Args> 
	struct __invoke_result: public __result_of_impl <is_member_object_pointer <typename remove_reference <FT>::type>::value, is_member_function_pointer <typename remove_reference <FT>::type>::value, FT, Args...>::type {};
	template <typename F2, typename...Args> 
	using __invoke_result_t = typename __invoke_result <F2, Args...>::type;
	template <typename T> 
	using decay_t = typename decay <T>::type;
	template <bool CT, typename T = void> 
	using enable_if_t = typename enable_if <CT, T>::type;
	template <bool CT, typename TCT, typename FCT> 
	using conditional_t = typename conditional <CT, TCT, FCT>::type;
	template <typename...T> 
	using common_type_t = typename common_type <T...>::type;
	template <typename T> 
	using underlying_type_t = typename underlying_type <T>::type;
	template <typename T> 
	using result_of_t = typename result_of <T>::type;
	template <typename...> 
	using void_t = void;
	template <typename DT, typename AlwaysVoid, template <typename...> class OT, typename...Args> 
	struct __detector
	{
		using type = DT;
		using __is_detected = false_type;
	};
	template <typename DT, template <typename...> class OT, typename...Args> 
	struct __detector <DT, __void_t <OT <Args...>>, OT, Args...>
	{
		using type = OT <Args...>;
		using __is_detected = true_type;
	};
	template <typename DT, template <typename...> class OT, typename...Args> 
	using __detected_or = __detector <DT, void, OT, Args...>;
	template <typename DT, template <typename...> class OT, typename...Args> 
	using __detected_or_t = typename __detected_or <DT, OT, Args...>::type;
	template <typename T> 
	struct __is_swappable;
	template <typename T> 
	struct __is_nothrow_swappable;
	template <typename> 
	struct __is_tuple_like_impl: false_type {};
	template <typename T> 
	struct __is_tuple_like: public __is_tuple_like_impl <__remove_cvref_t <T>>::type {};
	template <typename T> 
	constexpr inline __require_all <__not_ <__is_tuple_like <T>>, is_move_constructible <T>, is_move_assignable <T>> swap(T &, T & ) noexcept(__and_ <is_nothrow_move_constructible <T>, is_nothrow_move_assignable <T>>::value);
	template <typename T, size_t _Nm> 
	constexpr inline __enable_if_t <__is_swappable <T>::value> swap(T( & __a)[_Nm], T( & __b)[_Nm]) noexcept(__is_nothrow_swappable <T>::value);
	namespace __swappable_details
	{
		using std::swap;
		struct __do_is_swappable_impl
		{
			template <typename T, typename = decltype(swap(declval <T &> (), declval <T &> ()))> static true_type __test(int);
			template <typename> static false_type __test(...);
		};
		struct __do_is_nothrow_swappable_impl
		{
			template <typename T> static __bool_constant <noexcept(swap(declval <T &> (), declval <T &> ()))> __test(int);
			template <typename> static false_type __test(...);
		};
	}
	template <typename T> 
	struct __is_swappable_impl: public __swappable_details::__do_is_swappable_impl
	{
		using type = decltype(__test <T> (0));
	};
	template <typename T> 
	struct __is_nothrow_swappable_impl: public __swappable_details::__do_is_nothrow_swappable_impl
	{
		using type = decltype(__test <T> (0));
	};
	template <typename T> 
	struct __is_swappable: public __is_swappable_impl <T>::type {};
	template <typename T> 
	struct __is_nothrow_swappable: public __is_nothrow_swappable_impl <T>::type {};
	template <typename T> 
	struct is_swappable: public __is_swappable_impl <T>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	struct is_nothrow_swappable: public __is_nothrow_swappable_impl <T>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> 
	inline constexpr bool is_swappable_v = is_swappable <T>::value;
	template <typename T> 
	inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable <T>::value;
	namespace __swappable_with_details
	{
		using std::swap;
		struct __do_is_swappable_with_impl
		{
			template <typename T, typename U, typename = decltype(swap(declval <T> (), declval <U> ())), typename = decltype(swap(declval <U> (), declval <T> ()))> static true_type __test(int);
			template <typename, typename> static false_type __test(...);
		};
		struct __do_is_nothrow_swappable_with_impl
		{
			template <typename T, typename U> static __bool_constant <noexcept(swap(declval <T> (), declval <U> ())) && noexcept(swap(declval <U> (), declval <T> ()))> __test(int);
			template <typename, typename> static false_type __test(...);
		};
	}
	template <typename T, typename U> 
	struct __is_swappable_with_impl: public __swappable_with_details::__do_is_swappable_with_impl
	{
		using type = decltype(__test <T, U> (0));
	};
	template <typename T> 
	struct __is_swappable_with_impl <T &, T &>: public __swappable_details::__do_is_swappable_impl
	{
		using type = decltype(__test <T &> (0));
	};
	template <typename T, typename U> 
	struct __is_nothrow_swappable_with_impl: public __swappable_with_details::__do_is_nothrow_swappable_with_impl
	{
		using type = decltype(__test <T, U> (0));
	};
	template <typename T> 
	struct __is_nothrow_swappable_with_impl <T &, T &>: public __swappable_details::__do_is_nothrow_swappable_impl
	{
		using type = decltype(__test <T &> (0));
	};
	template <typename T, typename U> 
	struct is_swappable_with: public __is_swappable_with_impl <T, U>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "first template argument must be a complete class or an unbounded array");
		static_assert(__is_complete_or_unbounded(__type_identity <U> {}), "second template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename U> 
	struct is_nothrow_swappable_with: public __is_nothrow_swappable_with_impl <T, U>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "first template argument must be a complete class or an unbounded array");
		static_assert(__is_complete_or_unbounded(__type_identity <U> {}), "second template argument must be a complete class or an unbounded array");
	};
	template <typename T, typename U> 
	inline constexpr bool is_swappable_with_v = is_swappable_with <T, U>::value;
	template <typename T, typename U> 
	inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with <T, U>::value;
	template <typename RST, typename RTT, bool = is_void <RTT>::value, typename = void> 
	struct __is_invocable_impl: false_type
	{
		using __nothrow_conv = false_type;
	};
	template <typename RST, typename RTT> 
	struct __is_invocable_impl <RST, RTT, true, __void_t <typename RST::type>>: true_type
	{
		using __nothrow_conv = true_type;
	};
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
	template <typename RST, typename RTT> 
	struct __is_invocable_impl <RST, RTT, false, __void_t <typename RST::type>>
	{
		private: using _Res_t = typename RST::type;
		static _Res_t __get() noexcept;
		template <typename T> static void __conv(__type_identity_t <T> ) noexcept;
		template <typename T, bool NTB = noexcept(__conv <T> (__get())), typename = decltype(__conv <T> (__get())), bool DB = false> 
		static __bool_constant <NTB && !DB> __test(int);
		template <typename T, bool = false> static false_type __test(...);
		public: 
			using type = decltype(__test <RTT, true> (1));
			using __nothrow_conv = decltype(__test <RTT> (1));
	};
	#pragma GCC diagnostic pop
	template <typename F2, typename...Args> 
	struct __is_invocable: __is_invocable_impl <__invoke_result <F2, Args...>, void>::type {};
	template <typename F2, typename T, typename...Args> constexpr bool __call_is_nt(__invoke_memfun_ref)
	{
		using U = typename __inv_unwrap <T>::type;
		return noexcept((declval <U> ().*declval <F2> ())(declval <Args> ()...));
	}
	template <typename F2, typename T, typename...Args> constexpr bool __call_is_nt(__invoke_memfun_deref)
	{
		return noexcept((( * declval <T> ()).*declval <F2> ())(declval <Args> ()...));
	}
	template <typename F2, typename T> constexpr bool __call_is_nt(__invoke_memobj_ref)
	{
		using U = typename __inv_unwrap <T>::type;
		return noexcept(declval <U> ().*declval <F2> ());
	}
	template <typename F2, typename T> constexpr bool __call_is_nt(__invoke_memobj_deref)
	{
		return noexcept(( * declval <T> ()).*declval <F2> ());
	}
	template <typename F2, typename...Args> constexpr bool __call_is_nt(__invoke_other)
	{
		return noexcept(declval <F2> ()(declval <Args> ()...));
	}
	template <typename RST, typename F2, typename...Args> 
	struct __call_is_nothrow: __bool_constant <__call_is_nt <F2, Args...> (typename RST::__invoke_type {})> {};
	template <typename F2, typename...Args> 
	using __call_is_nothrow_ = __call_is_nothrow <__invoke_result <F2, Args...>, F2, Args...>;
	template <typename F2, typename...Args> 
	struct __is_nothrow_invocable: __and_ <__is_invocable <F2, Args...>, __call_is_nothrow_ <F2, Args...>>::type {};
	#pragma GCC diagnostic push 
    #pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
	struct __nonesuchbase {};
	struct __nonesuch: private __nonesuchbase
	{
		~__nonesuch() = delete;
		__nonesuch(__nonesuch const & ) = delete;
		void operator = (__nonesuch const & ) = delete;
	};
	#pragma GCC diagnostic pop 
    template <typename FT, typename...Args> 
	struct invoke_result: public __invoke_result <FT, Args...>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <FT> {}), "FT must be a complete class or an unbounded array");
		static_assert((__is_complete_or_unbounded(__type_identity <Args> {}) && ...), "each argument type must be a complete class or an unbounded array");
	};
	template <typename F2, typename...Args> 
	using invoke_result_t = typename invoke_result <F2, Args...>::type;
	template <typename F2, typename...Args> 
	struct is_invocable: __is_invocable_impl <__invoke_result <F2, Args...>, void>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <F2> {}), "_Fn must be a complete class or an unbounded array");
		static_assert((__is_complete_or_unbounded(__type_identity <Args> {}) && ...), "each argument type must be a complete class or an unbounded array");
	};
	template <typename RTT, typename F2, typename...Args> 
	struct is_invocable_r: __is_invocable_impl <__invoke_result <F2, Args...>, RTT>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <F2> {}), "_Fn must be a complete class or an unbounded array");
		static_assert((__is_complete_or_unbounded(__type_identity <Args> {}) && ...), "each argument type must be a complete class or an unbounded array");
		static_assert(__is_complete_or_unbounded(__type_identity <RTT> {}), "_Ret must be a complete class or an unbounded array");
	};
	template <typename F2, typename...Args> 
	struct is_nothrow_invocable: __and_ <__is_invocable_impl <__invoke_result <F2, Args...>, void>, __call_is_nothrow_ <F2, Args...>>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <F2> {}), "_Fn must be a complete class or an unbounded array");
		static_assert((__is_complete_or_unbounded(__type_identity <Args> {}) && ...), "each argument type must be a complete class or an unbounded array");
	};
	template <typename RST, typename RTT> 
	using __is_nt_invocable_impl = typename __is_invocable_impl <RST, RTT>::__nothrow_conv;
	template <typename RTT, typename F2, typename...Args> 
	struct is_nothrow_invocable_r: __and_ <__is_nt_invocable_impl <__invoke_result <F2, Args...>, RTT>, __call_is_nothrow_ <F2, Args...>>::type
	{
		static_assert(__is_complete_or_unbounded(__type_identity <F2> {}), "_Fn must be a complete class or an unbounded array");
		static_assert((__is_complete_or_unbounded(__type_identity <Args> {}) && ...), "each argument type must be a complete class or an unbounded array");
		static_assert(__is_complete_or_unbounded(__type_identity <RTT> {}), "RTT must be a complete class or an unbounded array");
	};
	template <typename T> inline constexpr bool is_void_v = is_void <T>::value;
	template <typename T> inline constexpr bool is_null_pointer_v = is_null_pointer <T>::value;
	template <typename T> inline constexpr bool is_integral_v = is_integral <T>::value;
	template <typename T> inline constexpr bool is_floating_point_v = is_floating_point <T>::value;
	template <typename T> inline constexpr bool is_array_v = false;
	template <typename T> inline constexpr bool is_array_v <T[]> = true;
	template <typename T, size_t _Num> inline constexpr bool is_array_v <T[_Num]> = true;
	template <typename T> inline constexpr bool is_pointer_v = is_pointer <T>::value;
	template <typename T> inline constexpr bool is_lvalue_reference_v = false;
	template <typename T> inline constexpr bool is_lvalue_reference_v <T &> = true;
	template <typename T> inline constexpr bool is_rvalue_reference_v = false;
	template <typename T> inline constexpr bool is_rvalue_reference_v <T &&> = true;
	template <typename T> inline constexpr bool is_member_object_pointer_v = is_member_object_pointer <T>::value;
	template <typename T> inline constexpr bool is_member_function_pointer_v = is_member_function_pointer <T>::value;
	template <typename T> inline constexpr bool is_enum_v = __is_enum(T);
	template <typename T> inline constexpr bool is_union_v = __is_union(T);
	template <typename T> inline constexpr bool is_class_v = __is_class(T);
	template <typename T> inline constexpr bool is_reference_v = false;
	template <typename T> inline constexpr bool is_reference_v <T &> = true;
	template <typename T> inline constexpr bool is_reference_v <T &&> = true;
	template <typename T> inline constexpr bool is_arithmetic_v = is_arithmetic <T>::value;
	template <typename T> inline constexpr bool is_fundamental_v = is_fundamental <T>::value;
	template <typename T> inline constexpr bool is_object_v = is_object <T>::value;
	template <typename T> inline constexpr bool is_scalar_v = is_scalar <T>::value;
	template <typename T> inline constexpr bool is_compound_v = !is_fundamental_v <T>;
	template <typename T> inline constexpr bool is_member_pointer_v = is_member_pointer <T>::value;
	template <typename T> inline constexpr bool is_const_v = false;
	template <typename T> inline constexpr bool is_const_v <const T> = true;
	template <typename T> inline constexpr bool is_function_v = !is_const_v <const T>;
	template <typename T> inline constexpr bool is_function_v <T &> = false;
	template <typename T> inline constexpr bool is_function_v <T &&> = false;
	template <typename T> inline constexpr bool is_volatile_v = false;
	template <typename T> inline constexpr bool is_volatile_v <volatile T> = true;
	template <typename T> inline constexpr bool is_trivial_v = __is_trivial(T);
	template <typename T> inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(T);
	template <typename T> inline constexpr bool is_standard_layout_v = __is_standard_layout(T);
	template <typename T> inline constexpr bool is_empty_v = __is_empty(T);
	template <typename T> inline constexpr bool is_polymorphic_v = __is_polymorphic(T);
	template <typename T> inline constexpr bool is_abstract_v = __is_abstract(T);
	template <typename T> inline constexpr bool is_final_v = __is_final(T);
	template <typename T> inline constexpr bool is_signed_v = is_signed <T>::value;
	template <typename T> inline constexpr bool is_unsigned_v = is_unsigned <T>::value;
	template <typename T, typename...Args> inline constexpr bool is_constructible_v = __is_constructible(T, Args...);
	template <typename T> inline constexpr bool is_default_constructible_v = __is_constructible(T);
	template <typename T> inline constexpr bool is_copy_constructible_v = __is_constructible(T, __add_lval_ref_t <const T> );
	template <typename T> inline constexpr bool is_move_constructible_v = __is_constructible(T, __add_rval_ref_t <T> );
	template <typename T, typename U> inline constexpr bool is_assignable_v = __is_assignable(T, U);
	template <typename T> inline constexpr bool is_copy_assignable_v = __is_assignable(__add_lval_ref_t <T>, __add_lval_ref_t <const T> );
	template <typename T> inline constexpr bool is_move_assignable_v = __is_assignable(__add_lval_ref_t <T>, __add_rval_ref_t <T> );
	template <typename T> inline constexpr bool is_destructible_v = is_destructible <T>::value;
	template <typename T, typename...Args> inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(T, Args...);
	template <typename T> inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(T);
	template <typename T> inline constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(T, __add_lval_ref_t <const T> );
	template <typename T> inline constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(T, __add_rval_ref_t <T> );
	template <typename T, typename U> inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(T, U);
	template <typename T> inline constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(__add_lval_ref_t <T>, __add_lval_ref_t <const T> );
	template <typename T> inline constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(__add_lval_ref_t <T>, __add_rval_ref_t <T> );
	template <typename T> inline constexpr bool is_trivially_destructible_v = false;
	template <typename T> inline constexpr bool is_trivially_destructible_v <T &> = true;
	template <typename T> inline constexpr bool is_trivially_destructible_v <T &&> = true;
	template <typename T, size_t _Nm> inline constexpr bool is_trivially_destructible_v <T[_Nm]> = is_trivially_destructible_v <T>;
	template <typename T, typename...Args> inline constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(T, Args...);
	template <typename T> inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(T);
	template <typename T> inline constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(T, __add_lval_ref_t <const T> );
	template <typename T> inline constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(T, __add_rval_ref_t <T> );
	template <typename T, typename U> inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(T, U);
	template <typename T> inline constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(__add_lval_ref_t <T>, __add_lval_ref_t <const T> );
	template <typename T> inline constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(__add_lval_ref_t <T>, __add_rval_ref_t <T> );
	template <typename T> inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible <T>::value;
	template <typename T> inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(T);
	template <typename T> inline constexpr size_t alignment_of_v = alignment_of <T>::value;
	template <typename T> inline constexpr size_t rank_v = 0;
	template <typename T, size_t S> inline constexpr size_t rank_v <T[S]> = 1 + rank_v <T>;
	template <typename T> inline constexpr size_t rank_v <T[]> = 1 + rank_v <T>;
	template <typename T, unsigned _Idx = 0> inline constexpr size_t extent_v = 0;
	template <typename T, size_t S> inline constexpr size_t extent_v <T[S], 0> = S;
	template <typename T, unsigned _Idx, size_t S> inline constexpr size_t extent_v <T[S], _Idx> = extent_v <T, _Idx - 1>;
	template <typename T> inline constexpr size_t extent_v <T[], 0> = 0;
	template <typename T, unsigned _Idx> inline constexpr size_t extent_v <T[], _Idx> = extent_v <T, _Idx - 1>;
	template <typename T, typename U> inline constexpr bool is_same_v = false;
	template <typename T> inline constexpr bool is_same_v <T, T> = true;
	template <typename _Base, typename _Derived> inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);
	template <typename FT, typename TT> inline constexpr bool is_convertible_v = is_convertible <FT, TT>::value;
	template <typename F2, typename...Args> inline constexpr bool is_invocable_v = is_invocable <F2, Args...>::value;
	template <typename F2, typename...Args> inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable <F2, Args...>::value;
	template <typename RTT, typename F2, typename...Args> inline constexpr bool is_invocable_r_v = is_invocable_r <RTT, F2, Args...>::value;
	template <typename RTT, typename F2, typename...Args> inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r <RTT, F2, Args...>::value;
	template <typename T> 
	struct has_unique_object_representations: bool_constant <__has_unique_object_representations(remove_cv_t <remove_all_extents_t <T>> )>
	{
		static_assert(__is_complete_or_unbounded(__type_identity <T> {}), "template argument must be a complete class or an unbounded array");
	};
	template <typename T> inline constexpr bool has_unique_object_representations_v = has_unique_object_representations <T>::value;
	template <typename T> 
	struct is_aggregate: bool_constant <__is_aggregate(remove_cv_t <T> )> {};
	template <typename T> inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t <T> );
	template <typename T> 
	struct remove_cvref
	{
		using type = typename remove_cv <T>::type;
	};
	template <typename T> 
	struct remove_cvref <T &>
	{
		using type = typename remove_cv <T>::type;
	};
	template <typename T> 
	struct remove_cvref <T &&>
	{
		using type = typename remove_cv <T>::type;
	};
	template <typename T> 
	using remove_cvref_t = typename remove_cvref <T>::type;
	template <typename T> 
	struct type_identity
	{
		using type = T;
	};
	template <typename T> 
	using type_identity_t = typename type_identity <T>::type;
	template <typename T> 
	struct unwrap_reference
	{
		using type = T;
	};
	template <typename T> 
	struct unwrap_reference <reference_wrapper <T>>
	{
		using type = T &;
	};
	template <typename T> 
	using unwrap_reference_t = typename unwrap_reference <T>::type;
	template <typename T> 
	struct unwrap_ref_decay
	{
		using type = unwrap_reference_t <decay_t <T>>;
	};
	template <typename T> 
	using unwrap_ref_decay_t = typename unwrap_ref_decay <T>::type;
	template <typename T> inline constexpr bool is_bounded_array_v = false;
	template <typename T, size_t S> inline constexpr bool is_bounded_array_v <T[S]> = true;
	template <typename T> inline constexpr bool is_unbounded_array_v = false;
	template <typename T> inline constexpr bool is_unbounded_array_v <T[]> = true;
	template <typename T> 
	struct is_bounded_array: public bool_constant <is_bounded_array_v <T>> {};
	template <typename T> 
	struct is_unbounded_array: public bool_constant <is_unbounded_array_v <T>> {};
	template <typename FT, typename TT> 
	using __copy_cv = typename __match_cv_qualifiers <FT, TT>::__type;
	template <typename X, typename Y> 
	using __cond_res = decltype(false ? declval <X( & )()> ()() : declval <Y( & )()> ()());
	template <typename A, typename B, typename = void> 
	struct __common_ref_impl {};
	template <typename A, typename B> 
	using __common_ref = typename __common_ref_impl <A, B>::type;
	template <typename X, typename Y> 
	using __condres_cvref = __cond_res <__copy_cv <X, Y> &, __copy_cv <Y, X> &>;
	template <typename X, typename Y> 
	struct __common_ref_impl <X &, Y &, __void_t <__condres_cvref <X, Y>>>: enable_if <is_reference_v <__condres_cvref <X, Y>>, __condres_cvref <X, Y>> {};
	template <typename X, typename Y> 
	using __common_ref_C = remove_reference_t <__common_ref <X &, Y &>> &&;
	template <typename X, typename Y> 
	struct __common_ref_impl <X &&, Y &&, __require_all <is_convertible <X &&, __common_ref_C <X, Y>>, is_convertible <Y &&, __common_ref_C <X, Y>>>>
	{
		using type = __common_ref_C <X, Y>;
	};
	template <typename X, typename Y> 
	using __common_ref_D = __common_ref <const X &, Y &>;
	template <typename X, typename Y> 
	struct __common_ref_impl <X &&, Y &, __require_all <is_convertible <X &&, __common_ref_D <X, Y>>>>
	{
		using type = __common_ref_D <X,
		Y>;
	};
	template <typename X, typename Y> 
	struct __common_ref_impl <X &, Y &&>: __common_ref_impl <Y &&, X &> {};
	template <typename T, typename U, template <typename> class QT, template <typename> class UQT> 
	struct basic_common_reference {};
	template <typename T> 
	struct __xref
	{
		template <typename U> using __type = __copy_cv <T, U>;
	};
	template <typename T> 
	struct __xref <T &>
	{
		template <typename U>
		using __type = __copy_cv <T, U> &;
	};
	template <typename T> 
	struct __xref <T &&>
	{
		template <typename U> 
		using __type = __copy_cv <T, U> &&;
	};
	template <typename T1, typename T2> 
	using __basic_common_ref = typename basic_common_reference <remove_cvref_t <T1>, remove_cvref_t <T2>, __xref <T1>::template __type, __xref <T2>::template __type>::type;
	template <typename...T> 
	struct common_reference;
	template <typename...T> 
	using common_reference_t = typename common_reference <T...>::type;
	template <> 
	struct common_reference <> {};
	template <typename T0> 
	struct common_reference <T0>
	{
		using type = T0;
	};
	template <typename T1, typename T2, int _Bullet = 1, typename = void> 
	struct __common_reference_impl: __common_reference_impl <T1, T2, _Bullet + 1> {};
	template <typename T1, typename T2> 
	struct common_reference <T1, T2>: __common_reference_impl <T1, T2> {};
	template <typename T1, typename T2> 
	struct __common_reference_impl <T1 &, T2 &, 1, void_t <__common_ref <T1 &, T2 &>>>
	{
		using type = __common_ref <T1 &, T2 &>;
	};
	template <typename T1, typename T2> 
	struct __common_reference_impl <T1 &&, T2 &&, 1, void_t <__common_ref <T1 &&, T2 &&>>>
	{
		using type = __common_ref <T1 &&, T2 &&>;
	};
	template <typename T1, typename T2> 
	struct __common_reference_impl <T1 &, T2 &&, 1, void_t <__common_ref <T1 &, T2 &&>>>
	{
		using type = __common_ref <T1 &, T2 &&>;
	};
	template <typename T1, typename T2> 
	struct __common_reference_impl <T1 &&, T2 &, 1, void_t <__common_ref <T1 &&, T2 &>>>
	{
		using type = __common_ref <T1 &&, T2 &>;
	};
	template <typename T1, typename T2> 
	struct __common_reference_impl <T1, T2, 2, void_t <__basic_common_ref <T1, T2>>>
	{
		using type = __basic_common_ref <T1, T2>;
	};
	template <typename T1, typename T2> 
	struct __common_reference_impl <T1, T2, 3, void_t <__cond_res <T1, T2>>>
	{
		using type = __cond_res <T1, T2>;
	};
	template <typename T1, typename T2> 
	struct __common_reference_impl <T1, T2, 4, void_t <common_type_t <T1, T2>>>
	{
		using type = common_type_t <T1, T2>;
	};
	template <typename T1, typename T2> 
	struct __common_reference_impl <T1, T2, 5, void> {};
	template <typename T1, typename T2, typename...Ts> 
	struct common_reference <T1, T2, Ts...>: __common_type_fold <common_reference <T1, T2>, __common_type_pack <Ts...>> {};
	template <typename T1, typename T2, typename...Ts> 
	struct __common_type_fold <common_reference <T1, T2>, __common_type_pack <Ts...>, void_t <common_reference_t <T1, T2>>>: public common_reference <common_reference_t <T1, T2>, Ts...> {};
	namespace __detail
	{
		template<typename T>
		constexpr T* __null__() { return NULL; }
	}
	using ptrdiff_t = decltype(__detail::__null__<int>() - __detail::__null__<int>());
}
#endif