// <meta> -*- C++ -*-
// Copyright (C) 2025 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.
#ifndef __STD_META
#define __STD_META
#if (__cplusplus > 202302L) && (__cpp_impl_reflection >= 202506L)
#include <optional>
#include <source_location>
#include <span>
#include <string_view>
#include <vector>
namespace std
{
#if __has_builtin(__builtin_is_string_literal)
	consteval bool is_string_literal(const char* __p) { return __builtin_is_string_literal(__p); }
	consteval bool is_string_literal(const wchar_t* __p) { return __builtin_is_string_literal(__p); }
	consteval bool is_string_literal(const char8_t* __p) { return __builtin_is_string_literal(__p); }
	consteval bool is_string_literal(const char16_t* __p) { return __builtin_is_string_literal(__p); }
	consteval bool is_string_literal(const char32_t* __p) { return __builtin_is_string_literal(__p); }
#endif
	namespace meta
	{
		using info = decltype(^^int);
		class exception : public std::exception
		{
		private:
			string _M_what;
			u8string _M_u8what;
			info _M_from;
			source_location _M_where;
		public:
			consteval exception(u8string_view __what, info __from, source_location __where = source_location::current()) noexcept :
				_M_what		{ _S_exception_cvt_from_utf8(__what) },
				_M_u8what	{ __what },
				_M_from		{ __from },
				_M_where	{ __where }
			{}
			consteval exception(string_view __what, info __from, source_location __where = source_location::current()) noexcept :
				_M_what		{ __what },
				_M_u8what	{ _S_exception_cvt_to_utf8(__what) },
				_M_from		{ __from },
				_M_where	{ __where }
			{}
			consteval exception(const exception&) = default;
			consteval exception(exception&&) = default;
			consteval exception& operator=(const exception&) = default;
			consteval exception& operator=(exception&&) = default;
			consteval const char* what() const noexcept override
			{
				if(_M_what.size() == 0 && _M_u8what.size() != 0)
					asm("");
				return _M_what.c_str();
			}
			consteval u8string_view u8what() const noexcept { return _M_u8what.c_str(); }
			consteval info from() const noexcept { return _M_from; }
			consteval source_location where() const noexcept { return _M_where; }
		private:
			template<ranges::input_range RT> static consteval u8string_view _S_exception_cvt_to_utf8(RT&&);
			template<ranges::input_range RT> static consteval string_view _S_exception_cvt_from_utf8(RT&&);
		};
		enum class operators
		{
			op_new = 1,
			op_delete,
			op_array_new,
			op_array_delete,
			op_co_await,
			op_parentheses,
			op_square_brackets,
			op_arrow,
			op_arrow_star,
			op_tilde,
			op_exclamation,
			op_plus,
			op_minus,
			op_star,
			op_slash,
			op_percent,
			op_caret,
			op_ampersand,
			op_equals,
			op_pipe,
			op_plus_equals,
			op_minus_equals,
			op_star_equals,
			op_slash_equals,
			op_percent_equals,
			op_caret_equals,
			op_ampersand_equals,
			op_pipe_equals,
			op_equals_equals,
			op_exclamation_equals,
			op_less,
			op_greater,
			op_less_equals,
			op_greater_equals,
			op_spaceship,
			op_ampersand_ampersand,
			op_pipe_pipe,
			op_less_less,
			op_greater_greater,
			op_less_less_equals,
			op_greater_greater_equals,
			op_plus_plus,
			op_minus_minus,
			op_comma
		};
		using enum operators;
		consteval bool is_public(info);
		consteval bool is_protected(info);
		consteval bool is_private(info);
		consteval bool is_virtual(info);
		consteval bool is_pure_virtual(info);
		consteval bool is_override(info);
		consteval bool is_final(info);
		consteval bool is_deleted(info);
		consteval bool is_defaulted(info);
		consteval bool is_user_provided(info);
		consteval bool is_user_declared(info);
		consteval bool is_explicit(info);
		consteval bool is_noexcept(info);
		consteval bool is_bit_field(info);
		consteval bool is_enumerator(info);
		consteval bool is_annotation(info);
		consteval bool is_const(info);
		consteval bool is_volatile(info);
		consteval bool is_mutable_member(info);
		consteval bool is_lvalue_reference_qualified(info);
		consteval bool is_rvalue_reference_qualified(info);
		consteval bool has_static_storage_duration(info);
		consteval bool has_thread_storage_duration(info);
		consteval bool has_automatic_storage_duration(info);
		consteval bool has_internal_linkage(info);
		consteval bool has_module_linkage(info);
		consteval bool has_external_linkage(info);
		consteval bool has_c_language_linkage(info);
		consteval bool has_linkage(info);
		consteval bool is_complete_type(info);
		consteval bool is_enumerable_type(info);
		consteval bool is_variable(info);
		consteval bool is_type(info);
		consteval bool is_namespace(info);
		consteval bool is_type_alias(info);
		consteval bool is_namespace_alias(info);
		consteval bool is_function(info);
		consteval bool is_conversion_function(info);
		consteval bool is_operator_function(info);
		consteval bool is_literal_operator(info);
		consteval bool is_special_member_function(info);
		consteval bool is_constructor(info);
		consteval bool is_default_constructor(info);
		consteval bool is_copy_constructor(info);
		consteval bool is_move_constructor(info);
		consteval bool is_assignment(info);
		consteval bool is_copy_assignment(info);
		consteval bool is_move_assignment(info);
		consteval bool is_destructor(info);
		consteval bool is_function_parameter(info);
		consteval bool is_explicit_object_parameter(info);
		consteval bool has_default_argument(info);
		consteval bool has_ellipsis_parameter(info);
		consteval bool is_template(info);
		consteval bool is_function_template(info);
		consteval bool is_variable_template(info);
		consteval bool is_class_template(info);
		consteval bool is_alias_template(info);
		consteval bool is_conversion_function_template(info);
		consteval bool is_operator_function_template(info);
		consteval bool is_literal_operator_template(info);
		consteval bool is_constructor_template(info);
		consteval bool is_concept(info);
		consteval bool is_value(info);
		consteval bool is_object(info);
		consteval bool is_structured_binding(info);
		consteval bool is_class_member(info);
		consteval bool is_namespace_member(info);
		consteval bool is_nonstatic_data_member(info);
		consteval bool is_static_member(info);
		consteval bool is_base(info);
		consteval bool has_default_member_initializer(info);
		consteval bool has_parent(info);
		consteval bool has_template_arguments(info);
		consteval bool has_identifier(info);
		consteval operators operator_of(info);
		consteval string_view symbol_of(operators);
		consteval u8string_view u8symbol_of(operators);
		consteval string_view identifier_of(info);
		consteval u8string_view u8identifier_of(info);
		consteval string_view display_string_of(info);
		consteval u8string_view u8display_string_of(info);
		consteval source_location source_location_of(info);
		consteval info type_of(info);
		consteval info object_of(info);
		consteval info constant_of(info);
		consteval info parent_of(info);
		consteval info dealias(info);
		consteval info template_of(info);
		consteval vector<info> template_arguments_of(info);
		consteval vector<info> parameters_of(info);
		consteval info variable_of(info);
		consteval info return_type_of(info);
		struct access_context {
		private:
			consteval access_context(info __scope, info __designating_class) noexcept :
				_M_scope				{ __scope },
				_M_designating_class	{ __designating_class }
			{}
		public:
			access_context() = delete;
			consteval access_context(const access_context &) = default;
			consteval access_context(access_context &&) = default;
			consteval info scope() const { return _M_scope; }
			consteval info designating_class() const { return _M_designating_class; }
			static consteval access_context current() noexcept;
			static consteval access_context unprivileged() noexcept { return access_context(^^::, info{}); }
			static consteval access_context unchecked() noexcept { return access_context(info{}, info{}); }
			consteval access_context via(info) const;
			info _M_scope;
			info _M_designating_class;
		};
		consteval bool is_accessible(info, access_context);
		consteval bool has_inaccessible_nonstatic_data_members(info, access_context);
		consteval bool has_inaccessible_bases(info, access_context);
		consteval bool has_inaccessible_subobjects(info, access_context);
		consteval vector<info> members_of(info, access_context);
		consteval vector<info> bases_of(info, access_context);
		consteval vector<info> static_data_members_of(info, access_context);
		consteval vector<info> nonstatic_data_members_of(info, access_context);
		consteval vector<info> subobjects_of(info, access_context);
		consteval vector<info> enumerators_of(info);
		struct member_offset
		{
			ptrdiff_t bytes;
			ptrdiff_t bits;
			constexpr ptrdiff_t total_bits() const { return bytes * __CHAR_BIT__ + bits; }
			auto operator<=>(const member_offset&) const = default;
		};
		consteval member_offset offset_of(info);
		consteval size_t size_of(info);
		consteval size_t alignment_of(info);
		consteval size_t bit_size_of(info);
		template<typename T> consteval T extract(info);
		template<typename RT> concept reflection_range = ranges::input_range<RT> && same_as<ranges::range_value_t<RT>, info> && same_as<remove_cvref_t<ranges::range_reference_t<RT>>, info>;
		template<reflection_range RT = initializer_list<info>> consteval bool can_substitute(info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval info substitute(info, RT&&);
		template<typename T> requires(is_copy_constructible_v<T>) consteval info reflect_constant(T);
		template<typename T> requires(!is_function_v<remove_reference_t<T>>) consteval info reflect_object(T&);
		template<typename T> requires(is_function_v<remove_reference_t<T>>) consteval info reflect_function(T&);
		template<ranges::input_range RT> consteval info reflect_constant_string(RT&&);
		template<ranges::input_range RT> consteval info reflect_constant_array(RT&&);
		struct data_member_options
		{
			struct _Name
			{
				template<typename T> requires(constructible_from<u8string, T>) consteval _Name(T&& __n) : _M_is_u8(true), _M_u8s(std::forward<T>(__n)) {}
				template<typename T> requires(constructible_from<string, T>)
				consteval _Name(T&& __n) : _M_is_u8(false), _M_s(std::forward<T>(__n)) {}
			private:
				bool _M_is_u8;
				u8string _M_u8s;
				string _M_s;
				info _M_unused = {};
			};
			optional<_Name> name;
			optional<int> alignment;
			optional<int> bit_width;
			bool no_unique_address = false;
		};
		consteval info data_member_spec(info, data_member_options);
		consteval bool is_data_member_spec(info);
		template<reflection_range RT = initializer_list<info>> consteval info define_aggregate(info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval bool is_constructible_type(info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval bool is_trivially_constructible_type(info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval bool is_nothrow_constructible_type(info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval bool is_invocable_type(info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval bool is_invocable_r_type(info, info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval bool is_nothrow_invocable_type(info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval bool is_nothrow_invocable_r_type(info, info, RT&&);
		template<reflection_range RT = initializer_list<info>> consteval info common_type(RT&&);
		template<reflection_range RT = initializer_list<info>> consteval info common_reference(RT&&);
		template<reflection_range RT = initializer_list<info>> consteval info invoke_result(info, RT&&);
		consteval bool is_void_type(info);
		consteval bool is_null_pointer_type(info);
		consteval bool is_integral_type(info);
		consteval bool is_floating_point_type(info);
		consteval bool is_array_type(info);
		consteval bool is_pointer_type(info);
		consteval bool is_lvalue_reference_type(info);
		consteval bool is_rvalue_reference_type(info);
		consteval bool is_member_object_pointer_type(info);
		consteval bool is_member_function_pointer_type(info);
		consteval bool is_enum_type(info);
		consteval bool is_union_type(info);
		consteval bool is_class_type(info);
		consteval bool is_function_type(info);
		consteval bool is_reflection_type(info);
		consteval bool is_reference_type(info);
		consteval bool is_arithmetic_type(info);
		consteval bool is_fundamental_type(info);
		consteval bool is_object_type(info);
		consteval bool is_scalar_type(info);
		consteval bool is_compound_type(info);
		consteval bool is_member_pointer_type(info);
		consteval bool is_const_type(info);
		consteval bool is_volatile_type(info);
		consteval bool is_trivially_copyable_type(info);
		consteval bool is_standard_layout_type(info);
		consteval bool is_empty_type(info);
		consteval bool is_polymorphic_type(info);
		consteval bool is_abstract_type(info);
		consteval bool is_final_type(info);
		consteval bool is_aggregate_type(info);
		consteval bool is_consteval_only_type(info);
		consteval bool is_signed_type(info);
		consteval bool is_unsigned_type(info);
		consteval bool is_bounded_array_type(info);
		consteval bool is_unbounded_array_type(info);
		consteval bool is_scoped_enum_type(info);
		consteval bool is_default_constructible_type(info);
		consteval bool is_copy_constructible_type(info);
		consteval bool is_move_constructible_type(info);
		consteval bool is_assignable_type(info, info);
		consteval bool is_copy_assignable_type(info);
		consteval bool is_move_assignable_type(info);
		consteval bool is_swappable_with_type(info, info);
		consteval bool is_swappable_type(info);
		consteval bool is_destructible_type(info);
		consteval bool is_trivially_default_constructible_type(info);
		consteval bool is_trivially_copy_constructible_type(info);
		consteval bool is_trivially_move_constructible_type(info);
		consteval bool is_trivially_assignable_type(info, info);
		consteval bool is_trivially_copy_assignable_type(info);
		consteval bool is_trivially_move_assignable_type(info);
		consteval bool is_trivially_destructible_type(info);
		consteval bool is_nothrow_default_constructible_type(info);
		consteval bool is_nothrow_copy_constructible_type(info);
		consteval bool is_nothrow_move_constructible_type(info);
		consteval bool is_nothrow_assignable_type(info, info);
		consteval bool is_nothrow_copy_assignable_type(info);
		consteval bool is_nothrow_move_assignable_type(info);
		consteval bool is_nothrow_swappable_with_type(info, info);
		consteval bool is_nothrow_swappable_type(info);
		consteval bool is_nothrow_destructible_type(info);
		consteval bool is_implicit_lifetime_type(info);
		consteval bool has_virtual_destructor(info);
		consteval bool has_unique_object_representations(info);
		consteval bool reference_constructs_from_temporary(info, info);
		consteval bool reference_converts_from_temporary(info, info);
		consteval size_t rank(info);
		consteval size_t extent(info, unsigned = 0);
		consteval bool is_same_type(info, info);
		consteval bool is_base_of_type(info, info);
		consteval bool is_virtual_base_of_type(info, info);
		consteval bool is_convertible_type(info, info);
		consteval bool is_nothrow_convertible_type(info, info);
		consteval bool is_layout_compatible_type(info, info);
		consteval bool is_pointer_interconvertible_base_of_type(info, info);
		consteval info remove_const(info);
		consteval info remove_volatile(info);
		consteval info remove_cv(info);
		consteval info add_const(info);
		consteval info add_volatile(info);
		consteval info add_cv(info);
		consteval info remove_reference(info);
		consteval info add_lvalue_reference(info);
		consteval info add_rvalue_reference(info);
		consteval info make_signed(info);
		consteval info make_unsigned(info);
		consteval info remove_extent(info);
		consteval info remove_all_extents(info);
		consteval info remove_pointer(info);
		consteval info add_pointer(info);
		consteval info remove_cvref(info);
		consteval info decay(info);
		consteval info underlying_type(info);
		consteval info unwrap_reference(info);
		consteval info unwrap_ref_decay(info);
		consteval size_t tuple_size(info);
		consteval info tuple_element(size_t, info);
		consteval size_t variant_size(info);
		consteval info variant_alternative(size_t, info);
		consteval strong_ordering type_order(info, info);
		consteval vector<info> annotations_of(info);
		consteval vector<info> annotations_of_with_type(info, info);
		consteval access_context access_context::via(info __cls) const
		{
			if(__cls != info{} && (!std::meta::is_class_type(__cls) || !std::meta::is_complete_type(__cls)))
				throw std::meta::exception(u8"via argument other than null or complete class type reflection", ^^access_context::via);
			return access_context(_M_scope, __cls);
		}
	}
	template<ranges::input_range RT>
	consteval const ranges::range_value_t<RT>* define_static_string(RT&& __r) {
		auto __str = meta::reflect_constant_string(__r);
		return meta::extract<const ranges::range_value_t<RT>*>(__str);
	}
	template<ranges::input_range RT>
	consteval span<const ranges::range_value_t<RT>> define_static_array(RT&& __r)
	{
		using T = ranges::range_value_t<RT>;
		auto __array = meta::reflect_constant_array(__r);
		auto __type = meta::type_of(__array);
		if(meta::is_array_type(__type))
			return span<const T>(meta::extract<const T*>(__array), meta::extent(__type, 0U));
		else return span<const T>();
	}
	template<typename T>
	consteval const remove_cvref_t<T>* define_static_object(T&& __t)
	{
		using U = remove_cvref_t<T>;
		if constexpr(meta::is_class_type(^^U)) {
			auto __cst = meta::reflect_constant(std::forward<T>(__t));
			return std::addressof(meta::extract<const U&>(__cst));
		}
		else return std::define_static_array(span<const U>(std::addressof(__t), 1)).data();
	}
}
#endif
#endif