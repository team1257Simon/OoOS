#ifndef __VECTOR
#define __VECTOR
#include <bits/dynamic_buffer.hpp>
#include <bits/range_access.hpp>
#include <bits/stdexcept.h>
namespace std
{
	template<typename T, std::allocator_object<T> A = std::allocator<T>>
	class vector : protected __impl::__dynamic_buffer<T, A, false>
	{
		typedef __impl::__dynamic_buffer<T, A, false> __base;
	public:
		typedef typename __base::__value_type value_type;
		typedef typename __base::__allocator_type allocator_type;
		typedef typename __base::__size_type size_type;
		typedef typename __base::__difference_type difference_type;
		typedef typename __base::__reference reference;
		typedef typename __base::__const_reference const_reference;
		typedef typename __base::__pointer pointer;
		typedef typename __base::__const_pointer const_pointer;
		typedef ::__impl::__iterator<pointer, vector> iterator;
		typedef ::__impl::__iterator<const_pointer, vector> const_iterator;
		typedef std::reverse_iterator<iterator> reverse_iterator;
		typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
	private:
		constexpr static bool __nt_alloc() noexcept { return noexcept(declval<allocator_type>().allocate(declval<size_type>())); }
		constexpr static bool __nt_move_assign() noexcept { return is_nothrow_move_assignable_v<allocator_type> || !__has_move_propagate<allocator_type>; }
		constexpr static bool __nt_copy_assign() noexcept { return __nt_alloc() && (is_nothrow_copy_assignable_v<allocator_type> || !__has_copy_propagate<allocator_type>); }
		constexpr static bool __nt_move_construct() noexcept { return is_nothrow_copy_constructible_v<allocator_type>; }
		constexpr static bool __nt_copy_construct() noexcept { return __nt_alloc() && is_nothrow_copy_constructible_v<allocator_type>; }
		constexpr static bool __nt_assign_elem() noexcept { return is_nothrow_copy_assignable_v<value_type>; }
		template<typename ... Args> requires(constructible_from<T, Args...>)
		constexpr static bool __nt_in_place() noexcept { return std::is_nothrow_constructible_v<value_type, Args...>; }
	public:
		constexpr explicit vector(allocator_type const& alloc) noexcept(noexcept(allocator_type(alloc))) : __base(alloc) {}
		constexpr vector() noexcept(noexcept(allocator_type())) : __base() {}
		constexpr explicit vector(size_type count) noexcept(__nt_alloc() && noexcept(allocator_type())) : __base(count, allocator_type()) {}
		constexpr explicit vector(size_type count, const_reference value, allocator_type const& alloc = allocator_type()) noexcept(__nt_copy_construct()) : __base(count, value, alloc) {}
		template<matching_input_iterator<value_type> IT>
		constexpr vector(IT start, IT end, allocator_type const& alloc = allocator_type()) noexcept(__nt_copy_construct()) : __base(start, end, alloc) {}
		template<ranges::input_range RT>
		constexpr vector(RT&& r, allocator_type const& alloc = allocator_type())
		noexcept(__nt_copy_construct() && noexcept(ranges::begin(r)) && noexcept(ranges::end(r))) : vector(ranges::begin(r), ranges::end(r), alloc) {}
		constexpr vector(vector const& that) noexcept(__nt_copy_construct()) : __base(that) {}
		constexpr vector(vector&& that) noexcept(__nt_move_construct()) : __base(forward<__base>(that)) {}
		constexpr vector(vector const& that, allocator_type const& alloc) noexcept(__nt_copy_construct()) : __base(that, alloc) {}
		constexpr vector(vector&& that, allocator_type const& alloc) noexcept(__nt_move_construct()) : __base(forward<__base>(that), alloc) {}
		constexpr vector(initializer_list<T> init, allocator_type const& alloc = allocator_type()) noexcept(__nt_copy_construct()) : __base(init, alloc) {}
		constexpr vector& operator=(vector const& that) noexcept(__nt_copy_assign()) { this->__copy_assign(that); return *this; }
		constexpr vector& operator=(vector&& that) noexcept(__nt_move_assign()) { this->__move_assign(move(that)); return *this; }
		constexpr allocator_type get_allocator() const noexcept { return this->__get_alloc(); }
		constexpr iterator find(const_reference what) requires(equality_comparable<value_type>);
		constexpr const_iterator find(const_reference what) const requires(equality_comparable<value_type>);
		constexpr iterator insert(const_iterator pos, const_reference value) noexcept(__nt_alloc() && __nt_assign_elem());
		template<matching_input_iterator<value_type> IT> constexpr iterator insert(const_iterator pos, IT start, IT __end) noexcept(__nt_alloc() && __nt_assign_elem());
		template<typename ... Args> requires(constructible_from<T, Args...>) constexpr iterator emplace(const_iterator pos, Args&& ... args) noexcept(__nt_in_place<Args...>() && __nt_alloc());
		template<typename ... Args> requires(constructible_from<T, Args...>) constexpr reference emplace_back(Args&& ... args) noexcept(__nt_in_place<Args...>() && __nt_alloc());
		constexpr iterator erase(const_iterator pos);
		constexpr iterator erase(const_iterator start, const_iterator __end);
		constexpr void push_back(const_reference value) noexcept(__nt_alloc() && __nt_assign_elem()) { this->__append_element(value); }
		constexpr pointer data() noexcept { return this->__beg(); }
		constexpr const_pointer data() const noexcept { return this->__beg(); }
		constexpr reference at(size_type i) { return this->__get(i); }
		constexpr const_reference at(size_type i ) const { return this->__get(i); }
		constexpr reference operator[](size_type i) noexcept { return this->__get(i); }
		constexpr const_reference operator[](size_type i) const noexcept { return this->__get(i); }
		constexpr reference front() { return this->__get(0); }
		constexpr const_reference front() const { return this->__get(0); }
		constexpr reference back() { return this->__get_last(); }
		constexpr const_reference back() const { return this->__get_last(); }
		constexpr iterator begin() noexcept { return iterator(this->__beg()); }
		constexpr const_iterator cbegin() const noexcept { return const_iterator(this->__beg()); }
		constexpr const_iterator begin() const noexcept { return cbegin(); }
		constexpr iterator end() noexcept { return iterator(this->__cur()); }
		constexpr const_iterator cend() const noexcept { return const_iterator(this->__cur()); }
		constexpr const_iterator end() const noexcept { return cend(); }
		constexpr reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
		constexpr const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(cend()); }
		constexpr const_reverse_iterator rbegin() const noexcept { return crbegin(); }
		constexpr reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
		constexpr const_reverse_iterator crend() const noexcept { return const_reverse_iterator(cbegin()); }
		constexpr const_reverse_iterator rend() const noexcept { return crend(); }
		constexpr bool empty() const noexcept { return this->__size() == 0; }
		constexpr size_type size() const noexcept { return this->__size(); }
		constexpr size_type max_size() const noexcept { return this->__max_capacity(); }
		constexpr void reserve(size_type count) { if(count > this->__capacity()) this->__grow_buffer(size_type(count - this->__capacity())); }
		constexpr size_type capacity() const noexcept { return this->__capacity(); }
		constexpr void shrink_to_fit() { this->__trim_buffer(); }
		constexpr void clear() { this->__clear(); }
		template<std::matching_input_iterator<value_type> IT> constexpr void push_back(IT start, IT end) noexcept(__nt_alloc() && __nt_assign_elem()) { this->__append_elements(start, end); }
		constexpr void pop_back() { this->__erase_at_end(1UZ); }
		constexpr void swap(vector& that) noexcept { this->__swap(that); }
		extension constexpr operator bool() const noexcept { return this->__beg() != nullptr; }
		extension constexpr void size(size_type count) requires(is_default_constructible_v<value_type>);
	};
	template<typename T, allocator_object<T> A>
	constexpr typename vector<T, A>::iterator vector<T, A>::find(const_reference what)
	requires(equality_comparable<value_type>)
	{
		for(iterator i = begin(); i != end(); i++)
			if(*i == what)
				return i;
		return end();
	}
	template<typename T, allocator_object<T> A>
	constexpr typename vector<T, A>::const_iterator vector<T, A>::find(const_reference what) const
	requires(equality_comparable<value_type>)
	{
		for(const_iterator i = begin(); i != end(); i++)
			if(*i == what)
				return i;
		return end();
	}
	template<typename T, allocator_object<T> A>
	constexpr typename vector<T, A>::iterator vector<T, A>::insert(const_iterator pos, const_reference value) noexcept(__nt_alloc() && __nt_assign_elem())
	{
		pointer result	= this->__insert_element(pos.base(), value);
		if(result) return iterator(result);
		return end();
	}
	template<typename T, allocator_object<T> A>
	template<matching_input_iterator<typename __impl::__dynamic_buffer<T, A, false>::__value_type> IT>
	constexpr typename vector<T, A>::iterator vector<T, A>::insert(const_iterator pos, IT start, IT __end) noexcept(__nt_alloc() && __nt_assign_elem())
	{
		pointer result	= this->template __insert_elements<IT>(pos.base(), start, __end);
		if(result) return iterator(result);
		return end();
	}
	template<typename T, allocator_object<T> A>
	template<typename... Args>
	requires(constructible_from<T, Args...>)
	constexpr typename vector<T, A>::iterator vector<T, A>::emplace(const_iterator pos, Args&& ... args) noexcept(__nt_in_place<Args...>() && __nt_alloc())
	{
		pointer result	= this->__emplace_element(pos.base(), forward<Args>(args)...);
		if(result) return iterator(result);
		return end();
	}
	template<typename T, allocator_object<T> A>
	template<typename... Args>
	requires(constructible_from<T, Args...>)
	constexpr typename vector<T, A>::reference vector<T, A>::emplace_back(Args&& ... args) noexcept(__nt_in_place<Args...>() && __nt_alloc())
	{
		pointer result	= this->__emplace_at_end(forward<Args>(args)...);
		if(!result) throw std::bad_alloc();
		return *result;
	}
	template<typename T, allocator_object<T> A>
	constexpr typename vector<T, A>::iterator vector<T, A>::erase(const_iterator pos)
	{
		pointer result	= this->__erase(pos.base());
		if(result) return iterator(result);
		return end();
	}
	template<typename T, allocator_object<T> A>
	constexpr typename vector<T, A>::iterator vector<T, A>::erase(const_iterator start, const_iterator __end)
	{
		pointer result	= this->__erase_range(start.base(), __end.base());
		if(result) return iterator(result);
		return end();
	}
	extension template<typename T, allocator_object<T> A>
	constexpr void vector<T, A>::size(size_type count)
	requires(is_default_constructible_v<value_type>)
	{
		if(count)
		{
			size_type old_size	= this->__size();
			if(count < old_size)
			{
				if constexpr(!is_trivially_destructible_v<value_type>)
					for(pointer p = this->__get_ptr(count); p < this->__get_ptr(old_size); p++)
						p->~value_type();
			}
			else
			{
				reserve(count);
				if constexpr(!is_trivially_default_constructible_v<value_type>)
					for(pointer p = this->__get_ptr(old_size); p < this->__get_ptr(count); p++)
						construct_at(p);
			}
			this->__setc(count);
		}
		else this->clear();
	}
	template<input_iterator IT, typename VT = typename iterator_traits<IT>::value_type, allocator_object<VT> AT = allocator<VT>>
	vector(IT, IT, AT = AT()) -> vector<VT, AT>;
	template<ranges::input_range RT, typename VT = ranges::range_value_t<RT>, allocator_object<VT> AT = allocator<VT>>
	vector(RT&&, AT = AT()) -> vector<VT, AT>;
}
#endif